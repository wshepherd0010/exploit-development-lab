#!/usr/bin/env python3
from __future__ import annotations
from argparse import (
    Namespace as Options,
    ArgumentParser as Parser
)
from typing import (
    TypeVar,
    Generic,
    Union,
    Callable,
    Any,
    Annotated,
    Generator
)
from string import (
    ascii_uppercase,
    ascii_lowercase,
    digits
)
from struct import (
    pack,
    unpack
)
from sys import (
    stdout,
    stderr
)
from socket import (
    socket,
    AF_INET,
    SOCK_STREAM
)
from binascii import (
    unhexlify,
    hexlify
)
from threading import Event
from typing.io import IO
from boofuzz import *


""" Generic type definitions """


# Generic exception type
_E = TypeVar("_E", bound=Union[Exception, object, str])
# Generic byte-string type
_B = TypeVar("_B", bound=Union[str, bytes, list, None])
# Generic char-byte type
_C = TypeVar("_C", bound=Union[str, bytes, int, None])
# Generic socket-session type
_S = TypeVar("_S", bound=Union[Session, socket, None])


# noinspection PyMethodMayBeStatic,SpellCheckingInspection
class Fuzzer(Generic[_S, _E, _B, _C]):
    """ Description:

    (i) Fuzzing class for TCP-based services

    A. Implementations include:
        1.
    """

    # Usage with hints
    usage: str = """\n
    
    * Fuzzing & Debugging Tips *
     
        (i) Linux debugging with GDB:
         gdb -q --pid $(pgrep lin-server) --eval-command 'set follow-fork-mode child';

        (i) Windows debugging with CDB:
         cdb -pn win-server.exe -pd -c "g"
        
        (i) Set windbg as post mortem debugger:
         windbg.exe -I 
    
        (i) Fuzzing input parameter explained:     
         Format: -i (1)<parameter> (2)<value> (3)delimiter (4)fuzzValue (5)fuzzDel
         (1)<The parameter value or second argument> 
         (2)<The delimiter between parameter name and value>
         (3)<Enable fuzzing the value or second argument>
         (4)<Enable fuzzing the delimiter>

    * Fuzzing Process & Examples * 
    
        (1) Fuzz the target to trigger a crash 
         (i) Example using three parameters:
            python fuzz-server.py --fuzz \\
             -d fuzz_db -l fuzz_log \\
             -t 192.168.43.1 -p 65534 \\
             -i "FUZZ" "FUZZ" "" true false \\
             -i "time" "FUZZ" "" false false \\
             -i "debug" "FUZZ" "" false false    
         
         (i) Example skipping 19 test cases starting at 20:
            python fuzz-server.py --fuzz \\
             -d fuzz_db -l fuzz_log --skip 20 \\
             -t 192.168.43.1 -p 65534 \\
             -i "FUZZ" "FUZZ" "" true false \\
                          
        (2) Hex encode the command that crashed the target
          (i) Example of encoding the "debug" command to "6465627567":  
            python fuzz-server.py -th debug
            
        (3) Confirm crash using random pattern of n length
          (i) Example of prepending the "debug" command, generating random pattern of 2000 bytes:
            python fuzz-server.py --confirm \\
            -t 192.168.43.1 -p 65534 \\
            -pre 6465627567 -gp -s 2000
        
        (4) Decode the pattern from overwritten register(s)
          (i) Example of decoding the EIP value of "79413279" to "yA2y":
            python fuzz-server.py -fh 79413279
                
        (5) Locate the offset from the pattern of the overwritten register
          (i) Example of searching the 2000 byte pattern to find the offset 727 of ""yA2y":
              Note: This doesn't include the size of the prepended "debug" bytes!    
            python fuzz-server.py -find -o yA2y \\
            -s 2000 --confirm
        
        (6) Confirm control over registers
          (i) Example of sending "debug" plus 727 bytes of CC padding, followed by AAAAAAAA for the EIP, etc:    
            python fuzz-server.py --confirm \\
            -t 192.168.43.1 -p 65534 \\
            -pre 6465627567 -pad CC -s 727 \\
            -a AAAAAAAA -a BBBBBBBB
            
        (7) Confirm space for shellcode and/or bad characters
          (i) Example of crashing the target with 727 bytes of NOPs plus bytes between 00-FF, excluding 00, 0A, and 0D:
            python fuzz-server.py --confirm \\
            -t 192.168.43.1 -p 65534 -gc \\
            -pre 6465627567 -pad 90 -s 727 -b 000A0D  
            
        (8) Confirm execution of code using NOP padding and hex shellcode
          (i) Example of testing shellcode and prepending 16-NOPs to the payload:
            python fuzz-server.py --confirm \\
            -t 192.168.43.1 -p 65534 \\
            -pad 90 -s 16 -c DEADBEEF...DEADBEEF    
    \n"""

    def __init__(self: Fuzzer, opts: Options, **kw):
        """ Instance initializer
        :param opts: Namespace object containing instance attributes
        :param kw: Arbitrary keyword argument dictionaries
        """
        self.event: Event = Event()
        self.sock: _S = socket(AF_INET, SOCK_STREAM)
        self.buffSize: int = 4
        self.target: str = "192.168.43.1"
        self.port: int = 65534
        self.session: _S = None
        self.restarts: list = []
        self.dbName: str = "fuzz"
        self.logName: str = "fuzz"
        self.skipCases: int = 0
        self.set(**opts.__dict__).set(**kw)

    """ FUZZING INTERNAL CLASSES """

    class EventCapture(object):
        """ Event capture callback object
        """
        def __init__(self, *ag, **kw):
            """ Event capture initializer method
            :param ag: Arbitrary argument lists
            :param kw: Arbitrary keyword argument dictionaries
            """
            self.params: list = ag
            self.__dict__.update(**kw)

    class RestartEvent(EventHook):
        """ Restart event hook class
        """
        def __init__(self, callback: Callable, **kw):
            """ Restart event initializer method
            :param callback: Callable hook callback
            :param kw: Arbitrary keyword argument dictionaries
            """
            EventHook.__init__(self)
            self.__handlers = [callback]
            self.__dict__.update(**kw)

    """ Properties """

    @property
    def shellcode(self: Fuzzer) -> Annotated[bytes, """
        Shellcode bytes
    """]:
        """ Hex-decode shellcode
        :return: Bytes of shellcode
        """
        return unhexlify(self.get("code", ""))

    @property
    def remaining(self: Fuzzer) -> Annotated[int, """
        Remaining iterations
    """]:
        """ Length of remaining interations
        :return: Integer length value
        """
        left = 0
        try:
            left = len(self.get("input", []))
        except Exception as err:
            self.logError(f"remaining: {err}")
        return left

    @property
    def logFile(self: Fuzzer) -> Annotated[IO, """
        Logfile handle in append mode
    """]:
        """ Obtain file handle for appending to fuzzer log
        :return: Logfile handle IO
        """
        return open(f"{self.logName}-{self.target}.log", "a+")

    @property
    def database(self: Fuzzer) -> Annotated[str, """
        Fuzzing database name
    """]:
        """ Name of fuzzing database
        :return: String name value
        """
        return f"{self.logName}-{self.target}.db"
    
    @property
    def stopped(self: Fuzzer) -> Annotated[bool, """
        Check if fuzzer is stopped
    """]:
        """ Check if fuzzing stop event has been set
        :return: Boolean result
        """
        return self.event.is_set()

    """ Common Methods """

    def get(self: Fuzzer, key: str, *ag, **kw) -> Annotated[Any, """
        Attribute accessor method
    """]:
        """ Get instance attribute by key
        :param key: String key of attribute
        :param ag: Arbitrary argument lists
        :param kw: Arbitrary keyword argument dictionaries
        :return: Attribute value of any type
        """
        return self.__dict__.get(key, *ag, **kw)

    def set(self: Fuzzer, **kw) -> Annotated[Fuzzer, """
        Attribute mutator method
    """]:
        """ Set instance attribute values by key-pair
        :param kw: Arbitrary keyword argument dictionaries
        :return: Instance for fluent design patterns
        """
        self.__dict__.update(**kw)
        return self

    def fromHex(self: Fuzzer, value: _B) -> Annotated[bytes, """
        Hex-decode value to bytes
    """]:
        """ Hex-decode string or bytes value
        :param value: String or bytes value
        :return: Bytes of value
        """
        try:
            return unhexlify(self.toString(value).strip())
        except Exception as err:
            self.logError(f"fromHex: {err}")
            return b""

    @staticmethod
    def toString(value: _B) -> Annotated[str, """
        Cast value to string
    """]:
        """ Convert value to string
        :param value: String or bytes value
        :return: String value
        """
        return value.decode() if isinstance(value, bytes) else value

    @staticmethod
    def toBytes(value: _B) -> Annotated[bytes, """
        Cast value to bytes
    """]:
        """ Convert value to bytes
        :param value: String or bytes value
        :return: Bytes value
        """
        return value if isinstance(value, bytes) else value.encode()

    def fromHexArray(self, values: list) -> bytes:
        return b"".join([self.fromHex(value) for value in values])

    @staticmethod
    def pack(address: int) -> Annotated[bytes, """
        Pack integer to unsigned long in little endian bytes format
    """]:
        """ Cast DWORD integer to little endian bytes
        :param address: Integer of DWORD address
        :return: Bytes in little endian
        """
        return pack("<L", address)

    @staticmethod
    def unpack(address: bytes) -> Annotated[int, """
        Unpack little endian bytes to big endian unsigned long integer
    """]:
        """ Cast little endian bytes to DWORD integer
        :param address: Bytes of unsigned long address
        :return: Integer value
        """
        return unpack(">L", address)[0]

    """ Confirmation Methods """

    @staticmethod
    def pattern() -> Annotated[Generator[str], """
        Generate alphanumeric ASCII string pattern
    """]:
        """ Generate unique uppercase, lowercase, and number patterns
        :return: String generator
        """
        for x in ascii_uppercase:
            for y in ascii_lowercase:
                for z in digits:
                    yield f"{x}{y}{z}"

    def generatePattern(self: Fuzzer, size: int) -> Annotated[bytes, """
        Generate alphanumeric ASCII byte pattern of given size
    """]:
        """ Generate bytes pattern of given size
        :param size: Integer size of pattern to create
        :return: Bytes of pattern created
        """
        data: list[bytes] = []
        [
            data.append(char.encode())
            for char in self.pattern()
            if len(b"".join(data)) < size
        ]
        return b"".join(data[:size])

    def generateChars(self: Fuzzer, exclude: _C = b"") -> Annotated[bytes, """
        Generate character array of 0x00-0xff with optional exclusions
    """]:
        """ Generate char values between 0x00-0xff with optional exclusions
        :param exclude: Optional byte exclusions
        :return: Bytes of chars generated
        """
        exclude = list(
            bytes(list([exclude])) if isinstance(exclude, int)
            else self.toBytes(exclude)
        )
        return bytes([
            idx for idx in range(0x100) if idx not in exclude
        ])

    def findOffset(self: Fuzzer, key: str, size: int) -> Annotated[str, """
        Locate index of pattern string for a given size
    """]:
        """ Search unique pattern of given size for string key
        :param key: String key to search for
        :param size: Integer size of pattern to search
        :return: String result
        """
        pattern = self.generatePattern(size).decode("ascii")
        key = key.strip().encode().decode("ascii")
        result = pattern.find(key)
        if result < 0:
            key = list(key)
            key.reverse()
            key = "".join(key)
            result = pattern.find(key)
        return (
            f"{key} located at {result}" if result >= 0
            else f"Failed to locate {key}"
        )

    @staticmethod
    def getPadding(size: int, byte: _B = 0x90) -> Annotated[bytes, """
        Generate byte paddding of a given size
    """]:
        """ Create array of repeated bytes limited by size
        :param size: Integer size to limit padding
        :param byte: Byte to use for padding
        :return: Bytes of padding
        """
        return bytes([byte[0] if isinstance(byte, bytes) else byte]) * size

    @staticmethod
    def toHexAddress(data: int, right: bool = False) -> Annotated[str, """
        Convert integer value to hex-encoded address
    """]:
        """ Cast DWORD integer to the hex representation
        :param data: Integer DWORD value
        :param right: Boolean option to pad left or right
        :return: String hex address
        """
        address = hex(data).lstrip("0x")
        return (
            address.ljust(8, "0") if right
            else address.rjust(8, "0")
        )

    def toAddress(self: Fuzzer, data: _B, right: bool = False) -> Annotated[int, """
        Cast bytes to unsigned long integer 
    """]:
        """ Cast bytes to integer DWORD address
        :param data: Bytes to convert
        :param right: Boolean option to pad left or right
        :return: Integer value of address
        """
        address = self.toString(data).strip()
        address = str(
            address.ljust(8, "0") if right
            else address.rjust(8, "0")
        )
        return self.unpack(unhexlify(address))

    def connect(self: Fuzzer) -> Annotated[Fuzzer, """
        Establish TCP connection to target
    """]:
        """ Connect to target on specified TCP port
        :return: Instance for fluent design patterns
        """
        try:
            self.sock: socket = socket(AF_INET, SOCK_STREAM)
            self.sock.connect((self.target, self.port))
        except Exception as err:
            raise Exception(f"Connect error: {err}")
        return self

    def send(self: Fuzzer, buffer: bytes) -> Annotated[Fuzzer, """
        Send bytes to target via TCP socket
    """]:
        """ Send buffer of bytes through connected socket
        :param buffer: Bytes to send
        :return: Instance for fluent design patterns
        """
        try:
            self.sock.send(buffer)
        except Exception as err:
            raise Exception(f"Send error: {err}")
        return self

    def recv(self: Fuzzer, size: int) -> Annotated[bytes, """
        Receive buffer of given size from socket
    """]:
        """ Receive bytes from socket using size provided
        :param size: Integer size of bytes to receive
        :return: Bytes received
        """
        try:
            return self.sock.recv(size)
        except Exception as err:
            raise Exception(f"Receive error: {err}")

    def close(self: Fuzzer) -> Annotated[Fuzzer, """
        Terminate socket connection
    """]:
        """ Close connected TCP socket
        :return: Instance for fluent design patterns
        """
        try:
            self.sock.close()
        except Exception as err:
            print(f"Close error: {err}")
        return self

    def recvUntil(self: Fuzzer, flag: bytes) -> Annotated[bytes, """
        Receive bytes until pattern matched
    """]:
        """ Continue to receive bytes until flag matched
        :param flag: Bytes of pattern to match
        :return: Bytes received
        """
        data: bytes = bytes()
        while True:
            try:
                data += self.recv(self.buffSize)
                if flag in data:
                    break
            except Exception as er:
                print(f"Recieve error: {er}")
                break
        return data

    def confirmCrash(self: Fuzzer) -> Annotated[Fuzzer, """
        Confirm ability to consistently crash target
    """]:
        """ Automate the process to crash target to confirm overflow
        :return: Instance for fluent design patterns
        """
        try:
            if self.get("genPattern"):
                self.logInfo(f"Confirming crash pattern size: {self.get('size')}")
                payload = self.fromHexArray(self.get("prependBytes"))
                payload += self.generatePattern(self.get("size"))
                payload += self.fromHexArray(self.get("addBytes"))
                self.logInfo(f"Confirming crash")
                return self.send(payload)
        except Exception as err:
            self.logError(f"confirmCrash: {err}")
        return self

    def confirmCharsSpace(self: Fuzzer) -> Annotated[Fuzzer, """
        Confirm available space after crashing target
    """]:
        """ Automate the process of crashing target to identify space available
        :return: Instance for fluent design patterns
        """
        try:
            if self.get("genChars"):
                self.logInfo(f"Generating character sequence")
                payload = self.fromHexArray(self.get("prependBytes"))
                payload += self.getPadding(
                    self.get("size"),
                    self.fromHex(self.get("paddingChar"))
                )
                payload += self.generateChars(self.fromHex(self.get("exclude")))
                payload += self.fromHexArray(self.get("addBytes"))
                self.logInfo(f"Confirming characters excluding {self.get('exclude')}")
                return self.send(payload)
        except Exception as err:
            self.logError(f"confirmCharsSpace: {err}")
        return self

    def confirmControl(self: Fuzzer) -> Annotated[Fuzzer, """
        Crash target to confirm EIP control
    """]:
        """ Automate the process to crash target for confirmation of EIP control
        :return: Instance for fluent design patterns
        """
        try:
            self.logInfo(f"Generating payload")
            payload = self.fromHexArray(self.get("prependBytes"))
            payload += self.getPadding(
                self.get("size"),
                self.fromHex(self.get("paddingChar"))
            )
            payload += self.fromHex(self.get("code"))
            payload += self.fromHexArray(self.get("addBytes"))
            self.logInfo(f"Confirming control with {''.join(self.get('addBytes'))}")
            self.send(payload)
        except Exception as err:
            self.logError(f"confirmControl: {err}")
        return self

    def confirmFuzz(self: Fuzzer) -> Annotated[Fuzzer, """
        Fuzzing confirmation method
    """]:
        """ Main method for fuzzing confirmation
        :return: Instance for fluent design patterns
        """
        self.logInfo(f"Confirming fuzzed target: {self.target}:{self.port}")
        try:
            if self.get("searchOffset"):
                return self.logInfo(
                    self.findOffset(
                        self.get("offset"),
                        self.get("size")
                    )
                )
            self.logInfo(f"Connecting to target").connect()
            if self.get("genPattern"):
                self.confirmCrash()
            elif self.get("genChars"):
                self.confirmCharsSpace()
            else:
                self.confirmControl()
            self.logInfo(f"Disconnecting from target").close()
        except Exception as err:
            self.logError(f"confirmFuzz: {err}")
        return self

    """ Fuzzing Methods """

    def stop(self: Fuzzer) -> Annotated[Fuzzer, """
        Terminate fuzzing session
    """]:
        """ Set event flag to terminate fuzzing session
        :return: Instance for fluent design patterns
        """
        if not self.stopped:
            self.logInfo(f"Stopping session.").event.set()
        return self    

    def logOutput(self: Fuzzer, message: _E, error: bool = False) -> Annotated[Fuzzer, """
        Log fuzzing output
    """]:
        """ Log output to stdout and append to logfile
        :param message: Exception or string message value
        :param error: Boolean value of error or string
        :return: Instance for fluent design patterns
        """
        (stderr if error else stdout).write(f"{message}\n")
        self.logFile.write(f"{message}\n")
        return self

    def logError(self: Fuzzer, message: _E) -> Annotated[Fuzzer, """
        Log exception 
    """]:
        """ Log exception to stdout
        :param message: Exception message value
        :return: Instance for fluent design patterns
        """
        return self.logOutput(
            f"[!] ERROR: {type(self).__name__}.{message}",
            True
        )

    def logInfo(self: Fuzzer, message: _E) -> Annotated[Fuzzer, """
        Log informational message
    """]:
        """ Log informational message to stdout
        :param message: String or exception message
        :return: Instance for fluent design patterns
        """
        return self.logOutput(
            f"[i] INFO: {message}"
        )

    def restartCallback(self: Fuzzer, *ag, **kw) -> Annotated[bool, """
        Function callback for fuzzing restart event
    """]:
        """ Callback function for restart event
        :param ag: Arbitrary argument lists
        :param kw: Arbitrary keyword argument dictionaries
        :return: Boolean result
        """
        self.restarts.append(Fuzzer.EventCapture(*ag, **kw))
        self.logInfo(f"Callback received: {len(self.restarts)}")
        return False

    def getSession(self: Fuzzer, index: int = 0, **kw) -> Annotated[Fuzzer, """
        Initialize fuzzing session
    """]:
        """ Initialize boofuzz session at optional test index
        :param index: Integer of test index
        :param kw: Arbitrary keyword argument dictionaries
        :return: Instance for fluent design patterns
        """
        try:
            self.logInfo(f"Initializing session.")
            self.session = Session(
                ignore_connection_issues_when_sending_fuzz_data=False,
                check_data_received_each_request=True,
                restart_callbacks=[self.restartCallback],
                ignore_connection_aborted=False,
                reuse_target_connection=False,
                ignore_connection_reset=False,
                receive_data_after_fuzz=True,
                crash_threshold_request=1,
                db_filename=self.database,
                restart_threshold=1,
                index_start=index,
                fuzz_loggers=[
                    FuzzLoggerText(file_handle=self.logFile),
                    FuzzLoggerText(file_handle=stdout),
                ],
                target=Target(
                    connection=TCPSocketConnection(
                        self.target,
                        self.port
                    )
                ),
                **kw
            )
            self.session.on_failure = Fuzzer.RestartEvent(
                callback=self.restartCallback
            )
            self.logInfo(f"Session initialized.")
        except Exception as err:
            self.logError(f"getSession: {err}").stop()
        return self

    def startFuzz(
        self: Fuzzer,
        parameter: str = "FUZZ",
        value: str = "FUZZ",
        delimiter: str = "",
        fuzzValue: bool = False,
        fuzzDelimiter: bool = False,
        **kw
    ) -> Annotated[Fuzzer, """ Begin fuzzing session """]:
        """ Start boofuzz session with given settings
        :param parameter: String parameter name to fuzz
        :param value: String value name to fuzz
        :param delimiter: String delimiter to fuzz
        :param fuzzValue: Boolean indicator to fuzz value
        :param fuzzDelimiter: Boolean indicator to fuzz delimiter
        :param kw: Arbitrary keyword argument dictionaries
        :return: Instance for fluent design patterns
        """
        self.logInfo(f"Starting fuzz: {parameter} {value} {delimiter}")
        try:
            self.getSession(index=self.skipCases, **kw)
            s_initialize(parameter)
            s_string(parameter, fuzzable=fuzzValue)
            s_delim(delimiter, fuzzable=fuzzDelimiter)
            s_string(value, fuzzable=True)
            self.session.connect(s_get(parameter))
            self.session.fuzz()
        except Exception as err:
            self.logError(f"startFuzz: {err}")
        return self

    def fuzzNext(self: Fuzzer) -> Annotated[tuple, """
        Obtain next fuzzing parameters
    """]:
        """ Retrieve next parameters in tuple format
        :return: Tuple containing fuzzing parameters
        """
        nextFuzz: tuple = ()
        try:
            if not bool(self.remaining):
                self.stop()
                return nextFuzz
            ag: tuple = self.get("input", []).pop(0)
            nextFuzz = (
                str(ag[0]), str(ag[1]), str(ag[2]),
                bool(str(ag[3]) == "true"),
                bool(str(ag[4]) == "true")
            )
        except Exception as err:
            self.logError(f"fuzzNext: {err}")
            self.stop()
        return nextFuzz

    def fuzz(self: Fuzzer, **kw) -> Annotated[Fuzzer, """
        Main method to begin fuzzing process
    """]:
        """ Main method to kick off fuzzing process
        :param kw: Arbitrary keyword argument dictionaries
        :return: Instance for fluent design patterns
        """
        self.logInfo(f"Fuzzing target: {self.target}:{self.port}")
        while not self.stopped:
            try:
                self.startFuzz(*self.fuzzNext(), **kw)
            except KeyboardInterrupt:
                self.logInfo(f"Exit requested.")
                break
            except Exception as err:
                self.logError(f"startFuzz: {err}")
                break
            finally:
                if not bool(self.remaining):
                    self.stop()
                    break
        self.logInfo(f"Fuzzing complete.")
        input("Press any key to exit.")
        return self

    """ Entry Point """

    @staticmethod
    def main(**kw) -> Annotated[Fuzzer, """
        Static main entry point
    """]:
        """ Static entry point method to instantiate fuzzing instance
        :param kw: Arbitrary keyword argument dictionaries
        :return: Fuzzing instance
        """
        # Fuzzing parameters
        opts: Parser = Parser(
            description="** Fuzzing template for TCP/IP based applications **"
        )
        opts.add_argument(
            '-hints', '--hints',
            dest='hints',
            default=False,
            action='store_true',
            required=False,
            help='Display hints and tips'
        )
        opts.add_argument(
            '--fuzz',
            dest='fuzzTarget',
            default=False,
            action='store_true',
            required=False,
            help='Fuzz target over TCP/IP'
        )
        opts.add_argument(
            '--confirm',
            default=False,
            action='store_true',
            required=False,
            help='Confirm crash, control, space, bad-characters, or execution'
        )
        opts.add_argument(
            '-t', '--target',
            dest='target',
            default='192.168.43.1',
            type=str,
            required=False,
            help='Target IP address to connect to'
        )
        opts.add_argument(
            '-p', '--port',
            dest='port',
            default=65534,
            type=int,
            required=False,
            help='Target port to connect to'
        )
        opts.add_argument(
            '-l', '--logfile',
            dest='logName',
            default='fuzz',
            type=str,
            required=False,
            help='Logfile base name to log output'
        )
        opts.add_argument(
            '-d', '--database',
            dest='dbName',
            default='fuzz',
            type=str,
            required=False,
            help='Database base file name to log output'
        )
        opts.add_argument(
            '-i', '--input',
            dest='input',
            required=False,
            action='append',
            nargs=5,
            metavar=(
                'parameter',
                'value',
                'delimiter',
                'fuzzValue',
                'fuzzDelimiter'
            ),
            help='Input parameters for fuzzing'
        )
        # Confirmation parameters
        opts.add_argument(
            '-th', '--to-hex',
            dest='strToHex',
            default="",
            type=str,
            required=False,
            help='Convert a string to a hex and display the output'
        )
        opts.add_argument(
            '-fh', '--from-hex',
            dest='strFromHex',
            default="",
            type=str,
            required=False,
            help='Convert a string to from hex and display the output'
        )
        opts.add_argument(
            '-s', '--size',
            dest='size',
            default=0,
            type=int,
            required=False,
            help='Length of pattern to generate when confirming crash'
        )
        opts.add_argument(
            '-c', '--code',
            dest='code',
            default="",
            type=str,
            required=False,
            help='Hex encoded shellcode to send for confirmation'
        )
        opts.add_argument(
            '-a', '--append-bytes',
            dest='addBytes',
            default=[""],
            required=False,
            action='append',
            help='Hex encoded byte-code to append to shellcode or padding'
        )
        opts.add_argument(
            '-pre', '--prepend-bytes',
            dest='prependBytes',
            default=[""],
            required=False,
            action='append',
            help='Hex encoded byte-code to prepend to shellcode or padding'
        )
        opts.add_argument(
            '-o', '--offset-pattern',
            dest='offset',
            default="",
            type=str,
            required=False,
            help='Pattern to search to for when searching for pattern offset'
        )
        opts.add_argument(
            '-b', '--bad-bytes',
            dest='exclude',
            default="",
            type=str,
            required=False,
            help='Hex encoded bytes to exclude from byte code for bad-char confirmation'
        )
        opts.add_argument(
            '-pad', '--padding',
            dest='paddingChar',
            default="",
            type=str,
            required=False,
            help='Hex encoded byte to prepend as padding characters'
        )
        # Confirmation action parameters
        opts.add_argument(
            '-find', '--find-offset',
            dest='searchOffset',
            default=False,
            action='store_true',
            required=False,
            help='Search for offset based on pattern size sent during crash confirmation'
        )
        opts.add_argument(
            '-gp', '--generate-pattern',
            dest='genPattern',
            default=False,
            action='store_true',
            required=False,
            help='Generate and send byte pattern to target for crash confirmation'
        )
        opts.add_argument(
            '-gc', '--generate-chars',
            dest='genChars',
            default=False,
            action='store_true',
            required=False,
            help='Generate and append byte sequence 00-FF to confirm bad characters'
        )
        opts.add_argument(
            '-skip', '--skip',
            dest='skipCases',
            type=int,
            default=0,
            action='store',
            required=False,
            help='Skip number of test cases for follow on fuzzing'
        )
        opts: Options = opts.parse_args()
        fuzzer = Fuzzer(opts, **kw)
        if opts.fuzzTarget or opts.confirm:
            return fuzzer.fuzz() if opts.fuzzTarget else fuzzer.confirmFuzz()
        if not (opts.fuzzTarget or opts.confirm):
            if opts.hints:
                fuzzer.logOutput(fuzzer.usage)
            elif opts.strToHex:
                fuzzer.logOutput(fuzzer.toString(
                    hexlify(opts.strToHex.encode())
                ))
            elif opts.strFromHex:
                fuzzer.logOutput(fuzzer.toString(
                    unhexlify(opts.strFromHex.encode())
                ))
        return fuzzer


def main() -> Annotated[None, """
    Main procedural function outside of fuzzing class
"""]:
    """ Call static main method of fuzzing class
    :return:
    """
    Fuzzer.main()


if __name__ == "__main__":
    main()
